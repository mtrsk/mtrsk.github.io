Recently I've been collaborating with friends on [[https://github.com/Dr-Nekoma/lyceum][Lyceum]], an MMO game with an
[[https://www.erlang.org/][Erlang]] backend and a [[https://ziglang.org/][Zig]] + [[https://www.raylib.com/][Raylib]] client (as if erlang wasn't a weird enough of
a choice). Now, this is an unusual combination, but that's the whole reason [[https://github.com/Dr-Nekoma][our
pesky group]] exists in the first place (if you want to know more check [[https://duing.dev/posts/beyondhackers/][my
friend's Lemos post]]).

One can imagine that setting up such a development environment might be
nightmarish, but thankfully the 21st century brought us some interesting tools
that make Unix less of a mess to deal with, and yes, I'm talking about
[[https://nixos.org/][Nix]]. My goal here is to convince people who deal with more normal tools (~brew~,
~asdf~, ~<insert random linux package manager>~, ...) to give Nix a try.

* Devenv

We use [[https://devenv.sh/][devenv]] to setup our development shell, think of it as 

** A unified development shell for Erlang and Zig

#+BEGIN_SRC nix
  # (...)
  devShells = forAllSystems (
    system:
    let
      pkgs = nixpkgs.legacyPackages.${system};

      # Erlang shit
      erlangLatest = pkgs.erlang_27;
      erlangLibs = getErlangLibs erlangLatest;

      # Zig shit
      raylib = pkgs.raylib;
      zigLatest = pkgs.zig;

      linuxPkgs = with pkgs; [
        inotify-tools
        xorg.libX11
        xorg.libXrandr
        xorg.libXinerama
        xorg.libXcursor
        xorg.libXi
        xorg.libXi
        libGL
      ];
      darwinPkgs = with pkgs.darwin.apple_sdk.frameworks; [
        CoreFoundation
        CoreServices
      ];
    in
    {
      # (...)

      # `nix develop`
      default = devenv.lib.mkShell {
        inherit inputs pkgs;
        modules = [
          (
            { pkgs, lib, ... }:
            {
              packages =
                with pkgs;
                [
                  erlang-ls
                  erlfmt
                  just
                  rebar3
                  dbeaver-bin
                ]
                ++ lib.optionals stdenv.isLinux (linuxPkgs)
                ++ lib.optionals stdenv.isDarwin darwinPkgs;

              languages.erlang = {
                enable = true;
                package = erlangLatest;
              };

              languages.zig = {
                enable = true;
                package = zigLatest;
              };

              env = mkEnvVars pkgs erlangLatest erlangLibs raylib;

              scripts = {
                build.exec = "just build";
                server.exec = "just server";
              };

              enterShell = ''
                echo "Starting Erlang environment..."
                rebar3 get-deps
              '';

              services.postgres = {
                package = pkgs.postgresql_16.withPackages (p: with p; [ p.periods ]);
                enable = true;
                initialDatabases = [ { name = "mmo"; } ];
                port = 5432;
                listen_addresses = "127.0.0.1";
                initialScript = ''
                  CREATE USER admin SUPERUSER;
                  ALTER USER admin PASSWORD 'admin';
                  GRANT ALL PRIVILEGES ON DATABASE mmo to admin;
                '';
              };
            }
          )
        ];
      };
     # (...)
#+END_SRC

*** Running Postgres


#+BEGIN_SRC shell
  devenv up -d
#+END_SRC

And the list of supported services keeps growing, you can check it [[https://devenv.sh/services/#supported-services][here]].

** The CI environment

Since we are already went to the trouble of setting up a whole dev environmet
for Erlang and Zig, we should just make another one for when we need to run
builds and testing suites on CI.

#+BEGIN_SRC nix
    # `nix develop .#ci`
    # reduce the number of packages to the bare minimum needed for CI
    ci = pkgs.mkShell {
      env = mkEnvVars pkgs erlangLatest erlangLibs raylib;
      buildInputs = with pkgs; [
        erlangLatest
        heroku
        just
        rebar3
        zigLatest
      ];
    };
#+END_SRC

** Direnv

As if thigs weren't awesome enough, I need to talk about [[https://direnv.net/][direnv]], a simple toolig
that can make wonders and with a single ~.envrc~ in your project's repo you can
jump inside a certain development shell just by ~cd~-ing into the project's
directory. Here's an example of my ~.envrc~:

#+BEGIN_SRC
use flake . --impure
#+END_SRC

followed by a ~direnv allow~ in my shell:

#+BEGIN_SRC shell
  $ direnv allow   
  direnv: loading ~/Code/Personal/lyceum/.envrc                                                                                                                   
  direnv: using flake . --impure
  direnv: nix-direnv: Using cached dev shell
  Starting Erlang environment...
  ===> Verifying dependencies...
  direnv: export +AR +AS +CC +CONFIG_SHELL +CXX +DEVENV_DOTFILE +DEVENV_PROFILE +DEVENV_ROOT +DEVENV_RUNTIME +DEVENV_STATE +ERLANG_INTERFACE_PATH +ERLANG_PATH +ERL_AFLAGS +ERL_INCLUDE_PATH +IN_NIX_SHELL +LD +NIX_BINTOOLS +NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CC +NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CFLAGS_COMPILE +NIX_ENFORCE_NO_NATIVE +NIX_HARDENING_ENABLE +NIX_LDFLAGS +NIX_PKG_CONFIG_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_STORE +NM +OBJCOPY +OBJDUMP +PGDATA +PGHOST +PGPORT +PKG_CONFIG +PKG_CONFIG_PATH +RANLIB +RAYLIB_PATH +READELF +SIZE +SOURCE_DATE_EPOCH +STRINGS +STRIP +cmakeFlags +configureFlags +mesonFlags +name +system ~LOCALE_ARCHIVE ~PATH ~XDG_DATA_DIRS
#+END_SRC

That's it. Now every time I ~cd <lyceum-directory>~, I'll immediatly load the
whole development shell and be ready to commit stuff.

* Nix Build

In the previous step I've showed you our impure environment, there's no way (as
of now) to make things 100% pure while developing, specially because we need to
have a postgres service running to debug and test locally.

However, when we talk about releases, then things change, we need to find a way
to properly build our server. 

** A pure build of the Erlang server

This is the original reason I've decided to write this, it took me some time to
go through the [[https://nixos.org/manual/nixpkgs/stable/#sec-beam][NixOS BEAM manual]] and I've yet to know how to properly build this
project with the [[https://nixos.org/manual/nixpkgs/stable/#build-tools-rebar3][buildRebar3 Tools]]. Nevertheless, you can pull up a proper Nix +
Rebar3 with the derivations Nix already gives you.

#+BEGIN_SRC nix
  # Leverages nix to build the erlang backend release
  # nix build .#server
  server =
    let
      deps = import ./rebar-deps.nix { inherit (pkgs) fetchHex fetchFromGitHub fetchgit; };
    in
    pkgs.stdenv.mkDerivation {
      name = "server";
      version = "0.0.1";
      src = pkgs.lib.cleanSource ./.;
      buildInputs = with pkgs; [
        erlangLatest
        pkgs.stdenv.cc.cc.lib
        rebar3
        just
        gnutar
      ];
      nativeBuildInputs = with pkgs; [
        autoPatchelfHook
        coreutils
        gawk
        gnugrep
        libz
        ncurses
        openssl
        systemdLibs
      ];
      buildPhase = ''
        mkdir -p _checkouts
        # https://github.com/NixOS/nix/issues/670#issuecomment-1211700127
        export HOME=$(pwd)
        ${toString (
          pkgs.lib.mapAttrsToList (k: v: ''
            cp -R --no-preserve=mode ${v} _checkouts/${k}
          '') deps
        )}
        just release-nix
      '';
      installPhase = ''
        mkdir -p $out
        mkdir -p $out/database
        # Add migrations to the output as well, otherwise the server
        # breaks at runtime.
        cp -r database/migrations $out/database
        tar -xzf _build/prod/rel/*/*.tar.gz -C $out/
      '';
    };
#+END_SRC


* Containers

There is a treasure trove of examples in 

#+BEGIN_SRC nix
  # nix build .#dockerImage
  dockerImage = pkgs.dockerTools.buildLayeredImage {
    name = "lyceum";
    tag = "latest";
    created = "now";
    # This will copy the compiled erlang release to the image
    contents = [ server ];
    config = {
      Cmd = [
        "${server}/bin/server"
        "foreground"
      ];
      ExposedPorts = {
        "8080/tcp" = { };
      };
    };
  };
#+END_SRC


* Conclusion

** TODO

There is still much to do, and it can be left for a part II later.

- [ ] Properly build the client, it seems that [[https://github.com/nix-community/zon2nix][non2nix]] breaks with the [[https://github.com/nix-community/zon2nix/issues/6][format for
  zon files]], I'm not familiar with Zig toolig and ill take a look at this later
- [ ] We are still unsure where to deploy, but I really want to move away from
  Heroku and check what Nix has to offer to manager a fleet of VMs.

** Final thoughs

As I wanted to show here, we've used Nix all the way from defining a development
environment for the developers, to re-using some of the stuff in CI as well, to
later repurpose some of the flows to build our containers, all withing a single
tool. I wish modern devops was more about that, but it seems it'll take time for
people to realize what immutability, composition and functional programminng can
hand in hand and give us a better experience than one can find in most
places. Luckilly, Nix is gaining some traction and more people are talking about
it.

I've been using for the past 6 years in my workstations, I regret nothing, its a
tool worth learning (and there's still so much to learn about it), it makes my
live dealing with Unix systems less painfull.
