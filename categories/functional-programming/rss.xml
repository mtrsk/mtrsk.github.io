<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional Programming on Benevides&#39; Blog</title>
    <link>https://mtrsk.github.io/categories/functional-programming/</link>
    <description>Recent content in Functional Programming on Benevides&#39; Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://mtrsk.github.io/categories/functional-programming/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Supervisor</title>
      <link>https://mtrsk.github.io/notes/2024/supervisor/</link>
      <pubDate>Sun, 13 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/supervisor/</guid>
      <description>:ID: 2daf1307-afb4-49e4-98cb-66ac7eb27cf0&#xA;Supervisors are one of the most important features of Otp. They monitor other processes and take action if anything goes wrong, restarting the failed process or possibly escalating the problem to a higher level. Layering supervisors into supervision trees allows you to create highly fault-tolerant systems. (Logan, Merritt, and Carlsson 2010)</description>
    </item>
    <item>
      <title>Functional Programming</title>
      <link>https://mtrsk.github.io/notes/2024/functional-programming/</link>
      <pubDate>Fri, 11 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/functional-programming/</guid>
      <description>:ID: 171718cd-10fd-484b-8d77-0ffcffc29163&#xA;We often refer to the term functional programming, meaning the following programming techniques:&#xA;Composing functions for structuring programs and using recursion instead of loops. Purity, so that the result of a function is fully determined once its parameters have been fixed. Absence of side effects (doing literally nothing except evaluating the result). Immutability (the inability to change the value of a variable). (, Bragilevsky 2021)&#xA;References Bragilevsky, Vitaly. 2021.</description>
    </item>
    <item>
      <title>Erlang Ets</title>
      <link>https://mtrsk.github.io/notes/2024/erlang-ets/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/erlang-ets/</guid>
      <description>:ID: 37c6ea44-0c80-4c57-a36e-98d37e8a3413 :ROAM_ALIAS: &amp;ldquo;ETS&amp;rdquo;&#xA;Erlang Term Storage, commonly referred to as ETS, is a powerful storage engine built into Otp.</description>
    </item>
    <item>
      <title>Gen Server</title>
      <link>https://mtrsk.github.io/notes/2024/gen-server/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/gen-server/</guid>
      <description>:ID: 1cd8fd81-a7c4-44ea-8b7a-d803e9b491af&#xA;Much of the work you think of as the core of a program - calculating results, storing information, and preparing replies - will fit neatly into the gen_server behavior. It provides a core set of methods that let you set up a process, respond to requests, end the process gracefully, and even pass state to a new process if this one needs to be upgraded in place. (Laurent 2017, 148)</description>
    </item>
    <item>
      <title>Dializer</title>
      <link>https://mtrsk.github.io/notes/2024/dializer/</link>
      <pubDate>Wed, 09 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/dializer/</guid>
      <description>:ID: 54473599-719d-460b-92ba-3796dd951872&#xA;Dialyzer is a static analysis tool that identifies software discrepancies, such as definite type errors, code that is unreachable because of programming errors, and unnecessary tests in Erlang and Elixir modules or an entire codebases.&#xA;Erlang Type Notation We can define a subset of Erlang types as follows:&#xA;Type :: any() | none() | pid() | port() | reference() | [] | Atom | binary() | float() | Fun | Integer | [Type] | Tuple | Union | UserDefined Union :: Type1 | Type2 | .</description>
    </item>
    <item>
      <title>Haskell</title>
      <link>https://mtrsk.github.io/notes/2024/haskell/</link>
      <pubDate>Tue, 08 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/haskell/</guid>
      <description>:ID: a74d6aac-dbe9-48a6-83ca-648cd6ea933e&#xA;Haskell is a general purpose, purely Functional Programming language incorporating many recent innovations in programming language design. Haskell provides higher-order functions, non-strict semantics, static polymorphic typing, user-defined algebraic datatypes, pattern-matching, list comprehensions, a module system, a monadic I/O system, and a rich set of primitive datatypes, including lists, arrays, arbitrary and fixed precision integers, and floating-point numbers. Haskell is both the culmination and solidification of many years of research on non-strict functional languages.</description>
    </item>
    <item>
      <title>Erlang Shell</title>
      <link>https://mtrsk.github.io/notes/2024/erlang-shell/</link>
      <pubDate>Fri, 04 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/erlang-shell/</guid>
      <description>:ID: bcd04f60-0a4c-4213-90f7-139c0ddf5bef&#xA;Some features of the Erlang shell.&#xA;Basics Compiling and Running &amp;ldquo;Hello World&amp;rdquo; in the Shell -module(hello). -export([start/0]). start() -&amp;gt; io:format(&amp;#34;Hello world~n&amp;#34;). Running the hello.erl program in the erlang shell.&#xA;$ erl Erlang/OTP 26 [erts-14.2.5] [source] [64-bit] [smp:24:24] [ds:24:24:10] [async-threads:1] [jit:ns] Eshell V14.2.5 (press Ctrl+G to abort, type help(). for help) 1&amp;gt; c(hello). {ok,hello} 2&amp;gt; hello:start(). Hello world ok Compiling Outside the Erlang Shell $ erlc hello.erl $ erl -noshell -s hello start -s init stop erlc evokes the Erlang compiler from the command line.</description>
    </item>
    <item>
      <title>Error Handling In Erlang</title>
      <link>https://mtrsk.github.io/notes/2024/error-handling-in-erlang/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/error-handling-in-erlang/</guid>
      <description>:ID: 22ae9c25-3123-4ed8-b765-369ac89d2942&#xA;In Erlang we do exactly the opposite. We build our applications in two parts: a part that solves the problem and a part that corrects errors if they have occurred.&#xA;The part that solves the problem is written with as little defensive code as possible; we assume that all arguments to functions are correct and the programs will execute without errors.&#xA;The part that corrects errors is often generic, so the same error-correcting code can be used for many different applications.</description>
    </item>
    <item>
      <title>Concurrent Erlang</title>
      <link>https://mtrsk.github.io/notes/2024/concurrent-erlang/</link>
      <pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/concurrent-erlang/</guid>
      <description>:ID: 63607e63-4428-4578-bf2a-12a49649b49c&#xA;I’m sure you’ve met processes before, but only in the context of operating systems. In Erlang, processes belong to the programming language and not the operating system. This means that Erlang processes will have the same logical behavior on any operating system, so we can write portable concurrent code that can run on any operating system that supports Erlang.&#xA;In Erlang:&#xA;Creating and destroying processes is very fast. Sending messages between processes is very fast.</description>
    </item>
    <item>
      <title>Otp</title>
      <link>https://mtrsk.github.io/notes/2024/otp/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/otp/</guid>
      <description>:ID: 6ed3a191-0128-453e-b0b6-37c48593a6f0 :ROAM_ALIAS: &amp;ldquo;Open Telecom Platform&amp;rdquo;&#xA;Otp is a domain-independent set of frameworks, principles, and patterns that guide and support the structure, design, implementation, and deployment of Erlang systems. Using OTP in your projects will help you avoid accidental complexity: things that are difficult because you picked inadequate tools. (Cesarini and Vinoski 2016, 20)&#xA;Behaviors Behaviours are a way of formalizing common patterns in process-oriented programming. For example, the concept of a server is general and includes a large portion of all processes you’ll ever need to write.</description>
    </item>
    <item>
      <title>Sequential Erlang</title>
      <link>https://mtrsk.github.io/notes/2024/sequential-erlang/</link>
      <pubDate>Tue, 24 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/sequential-erlang/</guid>
      <description>:ID: f0da3356-3797-4ddc-8306-cd333f159754&#xA;The basic constructs of the Erlang language.&#xA;Datatypes Integers Large Integers are converted to bignums If you need to do calculations on integers using a base other than 10, you can use Base#Value notation. (Laurent 2017, 7)&#xA;Floats When you divide two integers with /, the result is automatically converted to a floating-point number. Integer division is handled by div and rem. Atoms In Erlang, atoms are used to represent constant values.</description>
    </item>
    <item>
      <title>Nix</title>
      <link>https://mtrsk.github.io/notes/2024/nix/</link>
      <pubDate>Sun, 22 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/nix/</guid>
      <description>:ID: 72d705ae-9f5c-402b-88e5-21744277319a&#xA;References </description>
    </item>
    <item>
      <title>Type Driven Development</title>
      <link>https://mtrsk.github.io/notes/2024/type-driven-development/</link>
      <pubDate>Mon, 15 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/type-driven-development/</guid>
      <description>:ID: 794f5acf-354c-49bf-943f-33480ade38f2&#xA;Idris is a pure Functional Programming language with Dependent Types&#xA;References: (Brady 2017) References Brady, Edwin. 2017. Type-Driven Development with Idris. Simon and Schuster. </description>
    </item>
    <item>
      <title>Designing For Scalability With Erlang</title>
      <link>https://mtrsk.github.io/notes/2024/designing-for-scalability-with-erlang/</link>
      <pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/designing-for-scalability-with-erlang/</guid>
      <description>:ID: ffac18bd-4e44-4a7b-8a3a-a85552c9b076&#xA;Otp is said to consist of three building blocks that, when used together, provide a solid approach to designing and developing systems in the problem domain we’ve just described. They are Erlang itself, tools and libraries, and a set of design principles. (Cesarini and Vinoski 2016, 20)&#xA;References Cesarini, Francesco, and Steve Vinoski. 2016. Designing for Scalability with Erlang/Otp: Implement Robust, Fault-Tolerant Systems. O’Reilly Media, Inc. </description>
    </item>
    <item>
      <title>Erlang</title>
      <link>https://mtrsk.github.io/notes/2024/erlang/</link>
      <pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/erlang/</guid>
      <description>:ID: de7d0e94-618f-4982-b3e5-8806d88cad5d&#xA;Resources:&#xA;Etudes for Erlang Joe Armstrong&amp;rsquo;s PHD thesis The Erlang view of the world can be summarized in the following statments (Armstrong 2003):&#xA;Everything is a process. Processes are strongly isolated. Process creation and destruction is a lightweight operation. Message passing is the only way for processes to interact. Processes have unique names. If you know the name of a process you can send it a message. Error handling is non-local.</description>
    </item>
    <item>
      <title>Monad</title>
      <link>https://mtrsk.github.io/notes/2024/monad/</link>
      <pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2024/monad/</guid>
      <description>:ID: a3e972e0-8db9-4556-9dca-0e4f6a663236&#xA;Haskell In Haskell, monads are defined as:&#xA;class Monad m where (&amp;gt;&amp;gt;=) :: m a -&amp;gt; ( a -&amp;gt; m b) -&amp;gt; m b (&amp;gt;&amp;gt;) :: m a -&amp;gt; m b -&amp;gt; m b return :: a -&amp;gt; m a Name Handles Signature Result Errors Either e a -&amp;gt; (a -&amp;gt; Either e b) -&amp;gt; Either e b Maybe Absent values Maybe a -&amp;gt; (a -&amp;gt; Maybe b) -&amp;gt; Maybe b IO Pure/Impure separation IO a -&amp;gt; (a -&amp;gt; IO b) -&amp;gt; IO b State Monadic State State a -&amp;gt; (a -&amp;gt; State b) -&amp;gt; State b Reader Environment Data Reader a -&amp;gt; (a -&amp;gt; Reader b) -&amp;gt; Reader b Writer Writer-Only Data Writer a -&amp;gt; (a -&amp;gt; Writer b) -&amp;gt; Writer b Parser Composing Parsers Parser a -&amp;gt; (a -&amp;gt; Parser b) -&amp;gt; Parser b </description>
    </item>
    <item>
      <title>Monoid</title>
      <link>https://mtrsk.github.io/notes/2023/monoid/</link>
      <pubDate>Sun, 08 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://mtrsk.github.io/notes/2023/monoid/</guid>
      <description>:ID: d89285be-d7a9-46a1-8a10-e14e73b66935&#xA;Definition A monoid is triple \(\left (\mathbb{M}, \cdot, 1 \right)\) such that:&#xA;\(\mathbb{M}\) is an non-empty set \(\cdot : \mathbb{M} \times \mathbb{M} \rightarrow \mathbb{M}\) is an associative mapping, i.e., \(\forall t_1, t_2, t_3 \in \mathbb{M}, (t_1 \cdot t_2) \cdot t_3 = t_1 \cdot (t_2 \cdot t_3)\). \(1 \in \mathbb{M}\) is the unit satisfying \(1 \cdot t = t = t \cdot 1, \forall t \in \mathbb{M}\). </description>
    </item>
  </channel>
</rss>
