<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
  Natural Deduction

    </title>
    <meta property="og:url" content="https://schonfinkel.github.io/notes/2024/natural-deduction/">
  <meta property="og:site_name" content="Benevides&#39; Blog">
  <meta property="og:title" content="Natural Deduction">
  <meta property="og:description" content=":ID: 1db8ac56-b188-4797-80ed-21ac950a77b9
In natural deduction, we have a collection of proof rules. They allow us to infer formulas from other formulas. By applying these rules in succession, we may infer a conclusion from a set of premises.
Suppose we have a set of formulas \(\phi_1, \phi_2, \phi_3, \ldots, \phi_n\), which we will call premises, and another formula, \(\psi\), which we will call a conclusion. By applying proof rules to the premises, we hope to get some more formulas, and by applying more proof rules to those, to eventually obtain the conclusion.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2024-10-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-10-16T00:00:00+00:00">
    <meta property="article:tag" content="Sequent Calculus">
<link rel="stylesheet" href="/css/main.min.1135c79bd24c232c465ba2c4e5a9644086ce3f8358dbd0e0d76c5e86d24f1fad.css" />
    
        <script type="text/javascript" src ="https://d3js.org/d3.v7.min.js"></script>
<link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>

    
  </head>
  <body><nav>
  <img
    src="/img/logo.png"
    alt="put your logo here"
    width="128"
    height="128"
  />
  <div>
    <h1>Benevides&#39; Blog</h1><p>&#34;Writing is nothing more than a guided dream.&#34;</p>
  </div>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/blogroll">BlogRoll</a></li>
  </ul>
</nav>
<main>
  <h2>Natural Deduction
    <small>
      <time>October 16, 2024</time>
    by Marcos Benevides


    </small>
  </h2><p>:ID:       1db8ac56-b188-4797-80ed-21ac950a77b9</p>
<blockquote>
<p>In natural deduction, we have a collection of proof rules. They allow us to
infer formulas from other formulas. By applying these rules in succession, we
may infer a conclusion from a set of premises.</p>
<p>Suppose we have a set of formulas \(\phi_1, \phi_2, \phi_3, \ldots, \phi_n\), which we will call
premises, and another formula, \(\psi\), which we will call a conclusion. By applying
proof rules to the premises, we hope to get some more formulas, and by applying
more proof rules to those, to eventually obtain the conclusion. This intention
we denote by:</p>
<p>\[\phi_1, \phi_2, \phi_3, \ldots, \phi_n \vdash \psi\]</p>
<p>This expression is called a <strong>sequent</strong>; it is valid if a proof for it can be
found.</p>
<p>(<a href="#citeproc_bib_item_1">Huth and Ryan 2004, 5</a>)</p>
</blockquote>
<h2 id="rules-for-natural-deduction">Rules for Natural Deduction</h2>
<h3 id="conjunction">Conjunction</h3>
<p>\begin{prooftree}
\AxiomC{$\phi$}
\AxiomC{$\psi$}
\RightLabel{$\land i$}
\BinaryInfC{$\phi \land \psi$}
\end{prooftree}</p>
<p>\begin{prooftree}
\AxiomC{$\phi \land \psi$}
\RightLabel{$\land e_1$}
\UnaryInfC{$\phi$}
\end{prooftree}</p>
<p>\begin{prooftree}
\AxiomC{$\phi \land \psi$}
\RightLabel{$\land e_2$}
\UnaryInfC{$\psi$}
\end{prooftree}</p>
<h3 id="double-negation">Double Negation</h3>
<p>\begin{prooftree}
\AxiomC{$\phi$}
\RightLabel{$\lnot \lnot i$}
\UnaryInfC{$\lnot \lnot \phi$}
\end{prooftree}</p>
<p>\begin{prooftree}
\AxiomC{$\lnot \lnot \phi$}
\RightLabel{$\lnot \lnot e$}
\UnaryInfC{$\phi$}
\end{prooftree}</p>
<h3 id="implication">Implication</h3>
<p>\begin{prooftree}
\AxiomC{$\phi$}
\AxiomC{$\phi \to \psi$}
\RightLabel{$\to_e$}
\BinaryInfC{$\psi$}
\end{prooftree}</p>
<p>in order to prove \(\phi \to \psi\), make a temporary assumption of \(\phi\) and then prove \(\psi\).</p>
<p>\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\psi$}
\RightLabel{$\to_i$}
\alwaysSingleLine
\UnaryInfC{$\phi \to \psi$}
\end{prooftree}</p>
<blockquote>
<p>Showing \(p \to q\) using the rule \(\to_i\) rule is now called <strong>type checking</strong>, an
important topic in the construction of compilers for typed programming
languages. (<a href="#citeproc_bib_item_1">Huth and Ryan 2004, 12</a>)</p>
</blockquote>
<h3 id="disjunction">Disjunction</h3>
<p>\begin{prooftree}
\AxiomC{$\phi$}
\RightLabel{$\lor i_1$}
\UnaryInfC{$\phi \lor \psi$}
\end{prooftree}</p>
<p>\begin{prooftree}
\AxiomC{$\psi$}
\RightLabel{$\lor i_2$}
\UnaryInfC{$\phi \lor \psi$}
\end{prooftree}</p>
<p>To dissasemble a disjunction, we need to show that either \(\phi \vdash \chi\) or \(\psi
\vdash \chi\):</p>
<p>\begin{prooftree}
\alwaysNoLine
\AxiomC{$\phi \lor \psi$}
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\chi$}
\AxiomC{[$\psi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\chi$}
\RightLabel{$\lor_e$}
\alwaysSingleLine
\TrinaryInfC{$\chi$}
\end{prooftree}</p>
<h3 id="negation">Negation</h3>
<p>\begin{prooftree}
\AxiomC{$\bot$}
\RightLabel{$\bot_e$}
\UnaryInfC{$\phi$}
\end{prooftree}</p>
<p>\begin{prooftree}
\AxiomC{$\psi$}
\AxiomC{$\lnot \psi$}
\RightLabel{$\lnot_e$}
\BinaryInfC{$\bot$}
\end{prooftree}</p>
<p>\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\bot$}
\RightLabel{$\lnot_i$}
\alwaysSingleLine
\UnaryInfC{$\lnot \phi$}
\end{prooftree}</p>
<h3 id="useful-derived-rules">Useful Derived Rules</h3>
<h4 id="modus-tollens">Modus Tollens</h4>
<p>\begin{prooftree}
\AxiomC{$\lnot \psi$}
\AxiomC{$\phi \to \psi$}
\RightLabel{MT}
\BinaryInfC{$\lnot \phi$}
\end{prooftree}</p>
<h4 id="law-of-the-excluded-middle">Law of the Excluded Middle</h4>
<p>\begin{prooftree}
\alwaysNoLine
\AxiomC{}
\RightLabel{LEM}
\alwaysSingleLine
\UnaryInfC{$\phi \lor \lnot \phi$}
\end{prooftree}</p>
<h4 id="proof-by-contradiction">Proof by Contradiction</h4>
<p>\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\lnot \phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\bot$}
\RightLabel{$PBC$}
\alwaysSingleLine
\UnaryInfC{$\phi$}
\end{prooftree}</p>
<h2 id="references">References</h2>
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Huth, Michael, and Mark Ryan. 2004. <i>Logic in Computer Science: Modelling and Reasoning About Systems</i>. Cambridge university press.</div>
</div>



   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   





<footer>
  </br>
  <p>
  Built with <a href="https://orgmode.org/">Orgmode</a>, <a href="https://www.gnu.org/software/emacs/">Emacs</a> and <a href="https://nixos.org/">Nix</a>, source code availiable <a href="https://github.com/mtrsk/mtrsk.github.io">here</a>.
  </p>
</footer>

      </main>
    </main>
  </body>
</html>
