:PROPERTIES:
:ID:       f0da3356-3797-4ddc-8306-cd333f159754
:EXPORT_HUGO_CATEGORIES: "FP"
:EXPORT_HUGO_TAGS: "Erlang"
:END:
#+title: Sequential Erlang

The basic constructs of the [[id:de7d0e94-618f-4982-b3e5-8806d88cad5d][Erlang]] language.

* Datatypes

** Integers
+ Large Integers are converted to ~bignums~

#+BEGIN_QUOTE
    If you need to do calculations on integers using a base other than 10, you can use
    Base#Value notation. [cite:@laurent2017 p.7]
#+END_QUOTE

** Floats

** Atoms
+ Used to denote datatypes with a fixed number of items.

** Tuples
+ Used to denote datatypes with a fixed number of items.
+ Access is normally done by position.

** Lists
+ Used to store a variable number of elements.
+ Access is normally done by parttern matching.

#+BEGIN_SRC 
  List = [ Element | List ] OR []
#+END_SRC

** Strings

** Records

#+BEGIN_QUOTE
(...) records provide a convenient way for associating a tag
with each of the elements in a tuple. This allows us to refer to an
element of a tuple by name and not by position. A pre-compiler
takes the record definition and replaces it with the appropriate tuple
reference. [cite:@armstrong2013]
#+END_QUOTE

#+BEGIN_SRC erlang
  -record(todo, {status=reminder,who=joe,text}).
#+END_SRC

to load a record from the the shell, one must use the ~rr~ command:

#+BEGIN_SRC shell
  1> rr("records.hrl").
  [todo]
  2> #todo{}.
  #todo{status = reminder,who = joe,text = undefined}
  3> X1 = #todo{status=urgent, text="Fix errata in book"}.
  #todo{status = urgent,who = joe,text = "Fix errata in book"}
  4> X2 = X1#todo{status=done}.
  #todo{status = done,who = joe,text = "Fix errata in book"}
#+END_SRC

** Maps

Maps are associative collections of key-value pairs.

#+BEGIN_SRC shell
  1> TaskPending = #{ status => pending, description => 'feed cats' }.
  #{status => pending,description => 'feed cats'}
  2> TaskDone = TaskPending#{ status := done }.
  #{status => done,description => 'feed cats'}
#+END_SRC

* Variables

#+BEGIN_QUOTE
Note that Erlang variables start with uppercase characters. So, ~X~, ~This~, and
~A_long_name~ are all variables. Names beginning with lowercase lettersâ€”for example,
~monday~ or ~friday~ are not variables but are symbolic constants called 
atoms. [cite:@armstrong2013]
#+END_QUOTE 

* Pattern Matching
Pattern matching is used for:
+ Assigning values to variables
+ Redirecting execution flows

  #+BEGIN_SRC erlang

  #+END_SRC

* Functions

** Built-in Functions
+ Conventionally, these are part of the ~erlang~ module.
+ Mostly written in C for fast execution.

*** List of BiFs

+ ~date()~
+ ~time()~
+ ~length(List)~
+ ~size(Tuple)~
+ ~atom_to_list(Atom)~
+ ~list_to_tuple(List)~
+ ~integer_to_list(1000)~
+ ~tuple_to_list(Tuple)~

** Recursion
*** Tail Recursion

* Guards

* Modules

** Defining Modules

#+BEGIN_SRC erlang
    -module(drop).
    -export([fall_velocity/1, mps_to_mph/1, mps_to_kph/1]).

    fall_velocity(Distance) -> math:sqrt(2 * 9.8 * Distance).
    mps_to_mph(Mps) -> 2.23693629 * Mps.
    mps_to_kph(Mps) -> 3.6 * Mps.
#+END_SRC

* Erlang Shell

** Seeing Your Bound Variables

~b()~ shows all bound variables in the current erlang shell.

#+BEGIN_SRC shell
    > b().
    N = 1
    Number = 5
#+END_SRC

** Clearing Bound Variables in the Shell

#+BEGIN_SRC shell
  > f(N).
  > f().
#+END_SRC

#+print_bibliography:

