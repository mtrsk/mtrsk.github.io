<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benevides&#39; Blog</title>
  <link href="https://schonfinkel.github.io/notes/"/>
  
    <link href="https://schonfinkel.github.io/notes/atom.xml" rel="self" type="application/atom+xml" />
  
  <updated>2024-12-20T01:59:32Z</updated>
  <author>
    
    
  </author>
  <generator>Hugo</generator>
  <id>https://schonfinkel.github.io/notes/</id>
  
  <entry>
    <title>Gen Event</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/gen-event/"/>
    <id>https://schonfinkel.github.io/notes/2024/gen-event/</id>
    <published>2024-12-19T00:00:00Z</published>
    <updated>2024-12-19T00:00:00Z</updated>
    <summary>:ID: 0372baa6-420e-483a-9621-7f80f1ad6974
Events are continuously being generated in the system, and Otp provides a framework for creating event streams and for hooking up handlers to act on the generated events. This framework is the foundation of the standard Otp Logging system. (Logan, Merritt, and Carlsson 2010, 170)
References Logan, Martin, Eric Merritt, and Richard Carlsson. 2010. Erlang and Otp in Action. Manning Publications Co. </summary>
    <content type="html">&lt;p&gt;:ID:       0372baa6-420e-483a-9621-7f80f1ad6974&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Events are continuously being generated in the system, and &lt;a href=&#34;/notes/2024/otp/&#34;&gt;Otp&lt;/a&gt; provides a
framework for creating event streams and for hooking up handlers to act on the
generated events. This framework is the foundation of the standard &lt;a href=&#34;/notes/2024/otp-logging/&#34;&gt;Otp Logging&lt;/a&gt;
system. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Logan, Merritt, and Carlsson 2010, 170&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Logan, Martin, Eric Merritt, and Richard Carlsson. 2010. &lt;i&gt;Erlang and Otp in Action&lt;/i&gt;. Manning Publications Co.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Erlang"/>
    
    <category term="Elixir"/>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Otp Logging</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/otp-logging/"/>
    <id>https://schonfinkel.github.io/notes/2024/otp-logging/</id>
    <published>2024-12-19T00:00:00Z</published>
    <updated>2024-12-19T00:00:00Z</updated>
    <summary>:ID: b9d1f9ae-ba8a-4290-b86a-ff8c812de23a</summary>
    <content type="html">&lt;p&gt;:ID:       b9d1f9ae-ba8a-4290-b86a-ff8c812de23a&lt;/p&gt;
</content>
    
    <category term="Erlang"/>
    
    <category term="Elixir"/>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Erlang Debugger</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/erlang-debugger/"/>
    <id>https://schonfinkel.github.io/notes/2024/erlang-debugger/</id>
    <published>2024-12-18T00:00:00Z</published>
    <updated>2024-12-18T00:00:00Z</updated>
    <summary>:ID: 1428d426-2004-43ac-8627-ca79ab5c23a2
To start the debugger, you can call debugger:start() from the Erlang Shell:
1&amp;gt; debugger:start(). </summary>
    <content type="html">&lt;p&gt;:ID:       1428d426-2004-43ac-8627-ca79ab5c23a2&lt;/p&gt;
&lt;p&gt;To start the debugger, you can call &lt;code&gt;debugger:start()&lt;/code&gt; from the &lt;a href=&#34;/notes/2024/erlang-shell/&#34;&gt;Erlang Shell&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  1&amp;gt; debugger:start&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    
    <category term="Erlang"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Mnesia</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/mnesia/"/>
    <id>https://schonfinkel.github.io/notes/2024/mnesia/</id>
    <published>2024-12-17T00:00:00Z</published>
    <updated>2024-12-17T00:00:00Z</updated>
    <summary>:ID: 568e0595-4bf0-40b5-981f-fd0aa9312785
Mnesia is a database management system (DBMS) that comes with Erlang. It uses the Erlang Term Storage and DETS underneath, but provides many more features than those components.
Creating the initial Database mnesia:create_schema([node()]) By default, Mnesia will store your table in RAM only (ram_copies) on the current node. This is speedy, but it means the data vanishes if the node crashes. If you specify disc_copies (note the spelling), Mnesia will keep a copy of the database on disk, but still use RAM for speed.</summary>
    <content type="html">&lt;p&gt;:ID:       568e0595-4bf0-40b5-981f-fd0aa9312785&lt;/p&gt;
&lt;p&gt;Mnesia is a database management system (DBMS) that comes with &lt;a href=&#34;/notes/2024/erlang/&#34;&gt;Erlang&lt;/a&gt;. It uses
the &lt;a href=&#34;/notes/2024/erlang-term-storage/&#34;&gt;Erlang Term Storage&lt;/a&gt; and DETS underneath, but provides many more features
than those components.&lt;/p&gt;
&lt;h2 id=&#34;creating-the-initial-database&#34;&gt;Creating the initial Database&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nn&#34;&gt;mnesia&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;create_schema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;By default, Mnesia will store your table in RAM only (&lt;code&gt;ram_copies&lt;/code&gt;) on the current
node. This is speedy, but it means the data vanishes if the node crashes. If you
specify &lt;code&gt;disc_copies&lt;/code&gt; (note the spelling), Mnesia will keep a copy of the database
on disk, but still use RAM for speed. You can also specify &lt;code&gt;disc_only_copies&lt;/code&gt;,
which will be slow. (&amp;hellip;) . By combining these options and (eventually) multiple
nodes, you should be able to create fast and resilient
systems. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Laurent 2017, 152&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--quoteend--&gt;
&lt;blockquote&gt;
&lt;p&gt;Your interactions with Mnesia should be contained in transactions, especially
when your database is shared across multiple nodes. The main &lt;code&gt;mnesia:write&lt;/code&gt;,
&lt;code&gt;mnesia:read&lt;/code&gt;, and &lt;code&gt;mnesia:delete&lt;/code&gt; methods work only within transactions,
period. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Laurent 2017, 155&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Laurent, Simon St. 2017. &lt;i&gt;Introducing Erlang: Getting Started in Functional Programming&lt;/i&gt;. O’Reilly Media, Inc.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Erlang"/>
    
    <category term="Elixir"/>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Erlang Interface</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/erlang-interface/"/>
    <id>https://schonfinkel.github.io/notes/2024/erlang-interface/</id>
    <published>2024-11-29T00:00:00Z</published>
    <updated>2024-11-29T00:00:00Z</updated>
    <summary>:ID: 6422d659-d57d-4672-a90a-0649b5cbe905</summary>
    <content type="html">&lt;p&gt;:ID:       6422d659-d57d-4672-a90a-0649b5cbe905&lt;/p&gt;
</content>
    
    <category term="Erlang"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Konig S Lemma</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/konig-s-lemma/"/>
    <id>https://schonfinkel.github.io/notes/2024/konig-s-lemma/</id>
    <published>2024-10-16T00:00:00Z</published>
    <updated>2024-10-16T00:00:00Z</updated>
    <summary>:ID: c3826363-989c-49d9-905f-f1349f5528b7
Definition A tree that is finitely branching but infinite must have an infinite branch.</summary>
    <content type="html">&lt;p&gt;:ID:       c3826363-989c-49d9-905f-f1349f5528b7&lt;/p&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition&lt;/h2&gt;
&lt;p&gt;A tree that is finitely branching but infinite must have an infinite branch.&lt;/p&gt;
</content>
    
    <category term="Graph Theory"/>
    
    
    <category term="Math"/>
    
  </entry>
  
  <entry>
    <title>Natural Deduction</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/natural-deduction/"/>
    <id>https://schonfinkel.github.io/notes/2024/natural-deduction/</id>
    <published>2024-10-16T00:00:00Z</published>
    <updated>2024-10-16T00:00:00Z</updated>
    <summary>:ID: 1db8ac56-b188-4797-80ed-21ac950a77b9
In natural deduction, we have a collection of proof rules. They allow us to infer formulas from other formulas. By applying these rules in succession, we may infer a conclusion from a set of premises.
Suppose we have a set of formulas \(\phi_1, \phi_2, \phi_3, \ldots, \phi_n\), which we will call premises, and another formula, \(\psi\), which we will call a conclusion. By applying proof rules to the premises, we hope to get some more formulas, and by applying more proof rules to those, to eventually obtain the conclusion.</summary>
    <content type="html">&lt;p&gt;:ID:       1db8ac56-b188-4797-80ed-21ac950a77b9&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In natural deduction, we have a collection of proof rules. They allow us to
infer formulas from other formulas. By applying these rules in succession, we
may infer a conclusion from a set of premises.&lt;/p&gt;
&lt;p&gt;Suppose we have a set of formulas \(\phi_1, \phi_2, \phi_3, \ldots, \phi_n\), which we will call
premises, and another formula, \(\psi\), which we will call a conclusion. By applying
proof rules to the premises, we hope to get some more formulas, and by applying
more proof rules to those, to eventually obtain the conclusion. This intention
we denote by:&lt;/p&gt;
&lt;p&gt;\[\phi_1, \phi_2, \phi_3, \ldots, \phi_n \vdash \psi\]&lt;/p&gt;
&lt;p&gt;This expression is called a &lt;strong&gt;sequent&lt;/strong&gt;; it is valid if a proof for it can be
found.&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Huth and Ryan 2004, 5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;rules-for-natural-deduction&#34;&gt;Rules for Natural Deduction&lt;/h2&gt;
&lt;h3 id=&#34;conjunction&#34;&gt;Conjunction&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\AxiomC{$\psi$}
\RightLabel{$\land i$}
\BinaryInfC{$\phi \land \psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi \land \psi$}
\RightLabel{$\land e_1$}
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi \land \psi$}
\RightLabel{$\land e_2$}
\UnaryInfC{$\psi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;double-negation&#34;&gt;Double Negation&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\RightLabel{$\lnot \lnot i$}
\UnaryInfC{$\lnot \lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\lnot \lnot \phi$}
\RightLabel{$\lnot \lnot e$}
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;implication&#34;&gt;Implication&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\AxiomC{$\phi \to \psi$}
\RightLabel{$\to_e$}
\BinaryInfC{$\psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;in order to prove \(\phi \to \psi\), make a temporary assumption of \(\phi\) and then prove \(\psi\).&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\psi$}
\RightLabel{$\to_i$}
\alwaysSingleLine
\UnaryInfC{$\phi \to \psi$}
\end{prooftree}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Showing \(p \to q\) using the rule \(\to_i\) rule is now called &lt;strong&gt;type checking&lt;/strong&gt;, an
important topic in the construction of compilers for typed programming
languages. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Huth and Ryan 2004, 12&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;disjunction&#34;&gt;Disjunction&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\RightLabel{$\lor i_1$}
\UnaryInfC{$\phi \lor \psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\psi$}
\RightLabel{$\lor i_2$}
\UnaryInfC{$\phi \lor \psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;To dissasemble a disjunction, we need to show that either \(\phi \vdash \chi\) or \(\psi
\vdash \chi\):&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{$\phi \lor \psi$}
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\chi$}
\AxiomC{[$\psi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\chi$}
\RightLabel{$\lor_e$}
\alwaysSingleLine
\TrinaryInfC{$\chi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;negation&#34;&gt;Negation&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\bot$}
\RightLabel{$\bot_e$}
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\psi$}
\AxiomC{$\lnot \psi$}
\RightLabel{$\lnot_e$}
\BinaryInfC{$\bot$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\bot$}
\RightLabel{$\lnot_i$}
\alwaysSingleLine
\UnaryInfC{$\lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;useful-derived-rules&#34;&gt;Useful Derived Rules&lt;/h3&gt;
&lt;h4 id=&#34;modus-tollens&#34;&gt;Modus Tollens&lt;/h4&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\lnot \psi$}
\AxiomC{$\phi \to \psi$}
\RightLabel{MT}
\BinaryInfC{$\lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;h4 id=&#34;law-of-the-excluded-middle&#34;&gt;Law of the Excluded Middle&lt;/h4&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{}
\RightLabel{LEM}
\alwaysSingleLine
\UnaryInfC{$\phi \lor \lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;h4 id=&#34;proof-by-contradiction&#34;&gt;Proof by Contradiction&lt;/h4&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\lnot \phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\bot$}
\RightLabel{$PBC$}
\alwaysSingleLine
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Huth, Michael, and Mark Ryan. 2004. &lt;i&gt;Logic in Computer Science: Modelling and Reasoning About Systems&lt;/i&gt;. Cambridge university press.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Sequent Calculus"/>
    
    
    <category term="Logic"/>
    
  </entry>
  
  <entry>
    <title>Tcp Ip</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/tcp-ip/"/>
    <id>https://schonfinkel.github.io/notes/2024/tcp-ip/</id>
    <published>2024-10-16T00:00:00Z</published>
    <updated>2024-10-16T00:00:00Z</updated>
    <summary>:ID: 3bdcfa3b-8fb6-4c4f-97d9-9abaf4aa4a8b
Unlike the Osi Model, but &amp;ldquo;Application&amp;rdquo;, &amp;ldquo;Presentation&amp;rdquo; and &amp;ldquo;Session&amp;rdquo; are folded in a single layer.
Transmission Control Protocol / Internet Protocol </summary>
    <content type="html">&lt;p&gt;:ID:       3bdcfa3b-8fb6-4c4f-97d9-9abaf4aa4a8b&lt;/p&gt;
&lt;p&gt;Unlike the &lt;a href=&#34;/notes/2024/osi-model/&#34;&gt;Osi Model&lt;/a&gt;, but &amp;ldquo;Application&amp;rdquo;, &amp;ldquo;Presentation&amp;rdquo; and &amp;ldquo;Session&amp;rdquo; are
folded in a single layer.&lt;/p&gt;
&lt;h2 id=&#34;transmission-control-protocol-internet-protocol&#34;&gt;Transmission Control Protocol / Internet Protocol&lt;/h2&gt;
&lt;figure&gt;&lt;img src=&#34;/img/notes/tcp_ip_diagram.png&#34;&gt;
&lt;/figure&gt;

</content>
    
    <category term="TCP/IP"/>
    
    
    <category term="Networking"/>
    
  </entry>
  
  <entry>
    <title>Osi Model</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/osi-model/"/>
    <id>https://schonfinkel.github.io/notes/2024/osi-model/</id>
    <published>2024-10-15T00:00:00Z</published>
    <updated>2024-10-15T00:00:00Z</updated>
    <summary>:ID: e1a39e7c-50a7-4ad8-84f0-dfb7a8864e8b
The Open Systems Interconnection (OSI) model is a reference tool for understanding data communications between any two networked systems. It divides the communications processes into seven layers. Each layer both performs specific functions to support the layers above it and offers services to the layers below it.
Physical Layer Data Link MAC Addressing Flow control Error control: Error detection, followed by correction and/or re-transmition. Line discipline Unit of measure: Frames Network IP Addressing Unit of measure: Packets Transport Responsible for providing and managing end-to-end transmission of messages between two end nodes.</summary>
    <content type="html">&lt;p&gt;:ID:       e1a39e7c-50a7-4ad8-84f0-dfb7a8864e8b&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Open Systems Interconnection (OSI) model is a reference tool for
understanding data communications between any two networked systems. It divides
the communications processes into seven layers. Each layer both performs
specific functions to support the layers above it and offers services to the
layers below it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;physical-layer&#34;&gt;Physical Layer&lt;/h2&gt;
&lt;h2 id=&#34;data-link&#34;&gt;Data Link&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MAC Addressing&lt;/li&gt;
&lt;li&gt;Flow control&lt;/li&gt;
&lt;li&gt;Error control: Error detection, followed by correction and/or re-transmition.&lt;/li&gt;
&lt;li&gt;Line discipline&lt;/li&gt;
&lt;li&gt;Unit of measure: Frames&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;network&#34;&gt;Network&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IP Addressing&lt;/li&gt;
&lt;li&gt;Unit of measure: Packets&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;transport&#34;&gt;Transport&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Responsible for providing and managing end-to-end transmission of messages
between two end nodes.&lt;/li&gt;
&lt;li&gt;Maps transport and network addresses, port-based.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;protocols&#34;&gt;Protocols&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TCP: Reliable transfer and guarantees error-free delivery of data in the
correct order.&lt;/li&gt;
&lt;li&gt;UDP: &amp;ldquo;Unreliable&amp;rdquo; transport, no sequence messages.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;session&#34;&gt;Session&lt;/h2&gt;
&lt;h2 id=&#34;presentation&#34;&gt;Presentation&lt;/h2&gt;
&lt;h2 id=&#34;application&#34;&gt;Application&lt;/h2&gt;
</content>
    
    
    <category term="Networking"/>
    
  </entry>
  
  <entry>
    <title>Partial Order</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/partial-order/"/>
    <id>https://schonfinkel.github.io/notes/2024/partial-order/</id>
    <published>2024-10-13T00:00:00Z</published>
    <updated>2024-10-13T00:00:00Z</updated>
    <summary>:ID: a7be7168-8d15-4fe0-a82c-9fd9348b3b93
A Relation \(R\) is said to be a reflexive partial order if its reflexive, antisymmetric, and transitive. </summary>
    <content type="html">&lt;p&gt;:ID:       a7be7168-8d15-4fe0-a82c-9fd9348b3b93&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;a href=&#34;/notes/2024/relation/&#34;&gt;Relation&lt;/a&gt; \(R\) is said to be a &lt;strong&gt;reflexive partial order&lt;/strong&gt; if its &lt;strong&gt;reflexive&lt;/strong&gt;,
&lt;strong&gt;antisymmetric&lt;/strong&gt;, and &lt;strong&gt;transitive&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <category term="Set Theory"/>
    
    
    <category term="Math"/>
    
  </entry>
  
  <entry>
    <title>Relation</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/relation/"/>
    <id>https://schonfinkel.github.io/notes/2024/relation/</id>
    <published>2024-10-13T00:00:00Z</published>
    <updated>2024-10-13T00:00:00Z</updated>
    <summary>:ID: efd79527-1cfb-48da-868e-6286cff21c34
A relation is any subset of a Cartesian product. For instance, a relation \(R\) over any subset of \(X \times X\) is called a &amp;ldquo;Relation on \(X\)&amp;rdquo;.
A Relation \(R\) is said to be reflexive if \(\forall x \in X: (x,x) \in R\). A Relation \(R\) is said to be symmetric if \(\forall x,y \in X: (x,y) \in R \implies (y,x) \in R\). A Relation \(R\) is antisymmetric if \(\forall x,y \in X: (x,y) \in R \land (y,x) \in R \implies x = y\).</summary>
    <content type="html">&lt;p&gt;:ID:       efd79527-1cfb-48da-868e-6286cff21c34&lt;/p&gt;
&lt;p&gt;A relation is any subset of a Cartesian product. For instance, a relation \(R\)
over any subset of \(X \times X\) is called a &amp;ldquo;Relation on \(X\)&amp;rdquo;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Relation \(R\) is said to be &lt;strong&gt;reflexive&lt;/strong&gt; if \(\forall x \in X: (x,x) \in R\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is said to be &lt;strong&gt;symmetric&lt;/strong&gt; if \(\forall x,y \in X: (x,y) \in R \implies (y,x)
\in R\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is &lt;strong&gt;antisymmetric&lt;/strong&gt; if \(\forall x,y \in X: (x,y) \in R \land (y,x) \in R \implies x
= y\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is &lt;strong&gt;transitive&lt;/strong&gt; if \(\forall x,y,z \in X: (x,y) \in R \land (y,z) \in R \implies
(x,z) \in R\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is &lt;strong&gt;reflexive&lt;/strong&gt;, &lt;strong&gt;symmetric&lt;/strong&gt; and &lt;strong&gt;transitive&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <category term="Set Theory"/>
    
    
    <category term="Math"/>
    
  </entry>
  
  <entry>
    <title>Supervisor</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/supervisor/"/>
    <id>https://schonfinkel.github.io/notes/2024/supervisor/</id>
    <published>2024-10-13T00:00:00Z</published>
    <updated>2024-10-13T00:00:00Z</updated>
    <summary>:ID: 2daf1307-afb4-49e4-98cb-66ac7eb27cf0
Supervisors are one of the most important features of Otp. They monitor other processes and take action if anything goes wrong, restarting the failed process or possibly escalating the problem to a higher level. Layering supervisors into supervision trees allows you to create highly fault-tolerant systems. (Logan, Merritt, and Carlsson 2010)
A simple-one-for-one supervisor hierarchy. All the child processes are of the same type and are added or removed dynamically.</summary>
    <content type="html">&lt;p&gt;:ID:       2daf1307-afb4-49e4-98cb-66ac7eb27cf0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Supervisors are one of the most important features of &lt;a href=&#34;/notes/2024/otp/&#34;&gt;Otp&lt;/a&gt;. They monitor other
processes and take action if anything goes wrong, restarting the failed process
or possibly escalating the problem to a higher level. Layering supervisors into
supervision trees allows you to create highly fault-tolerant systems. (Logan, Merritt, and Carlsson 2010)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A simple-one-for-one supervisor hierarchy. All the child processes are of the
same type and are added or removed dynamically. There can be any number of them.&lt;/p&gt;
</content>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Dependent Types</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/dependent-types/"/>
    <id>https://schonfinkel.github.io/notes/2024/dependent-types/</id>
    <published>2024-10-11T00:00:00Z</published>
    <updated>2024-10-11T00:00:00Z</updated>
    <summary>:ID: 7580b45a-1dba-4690-bfbf-652fee25e1d9</summary>
    <content type="html">&lt;p&gt;:ID:       7580b45a-1dba-4690-bfbf-652fee25e1d9&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/functional-programming/"/>
    <id>https://schonfinkel.github.io/notes/2024/functional-programming/</id>
    <published>2024-10-11T00:00:00Z</published>
    <updated>2024-10-11T00:00:00Z</updated>
    <summary>:ID: 171718cd-10fd-484b-8d77-0ffcffc29163
We often refer to the term functional programming, meaning the following programming techniques:
Composing functions for structuring programs and using recursion instead of loops. Purity, so that the result of a function is fully determined once its parameters have been fixed. Absence of side effects (doing literally nothing except evaluating the result). Immutability (the inability to change the value of a variable). (, Bragilevsky 2021)
References Bragilevsky, Vitaly. 2021.</summary>
    <content type="html">&lt;p&gt;:ID:       171718cd-10fd-484b-8d77-0ffcffc29163&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We often refer to the term functional programming, meaning the following programming techniques:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Composing functions for structuring programs and using recursion instead of loops.&lt;/li&gt;
&lt;li&gt;Purity, so that the result of a function is fully determined once its parameters have been fixed.&lt;/li&gt;
&lt;li&gt;Absence of side effects (doing literally nothing except evaluating the result).&lt;/li&gt;
&lt;li&gt;Immutability (the inability to change the value of a variable).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(, &lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Bragilevsky 2021&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Bragilevsky, Vitaly. 2021. &lt;i&gt;Haskell in Depth&lt;/i&gt;. Simon and Schuster.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Erlang Term Storage</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/erlang-term-storage/"/>
    <id>https://schonfinkel.github.io/notes/2024/erlang-term-storage/</id>
    <published>2024-10-10T00:00:00Z</published>
    <updated>2024-10-10T00:00:00Z</updated>
    <summary>:ID: 37c6ea44-0c80-4c57-a36e-98d37e8a3413 :ROAM_ALIAS: &amp;ldquo;ETS&amp;rdquo;
Erlang Term Storage, commonly referred to as ETS, is a powerful storage engine built into Otp. Every entry in an ETS table is a tuple (or corresponding record), and one piece of the tuple is designated the key.
ETS can hold four kinds of collections (Laurent 2017, 141):
Sets (set): Can contain only one entry with a given key. Ordered Sets (ordered_set): Same as a set, but also maintains a traversal order based on the keys.</summary>
    <content type="html">&lt;p&gt;:ID:       37c6ea44-0c80-4c57-a36e-98d37e8a3413
:ROAM_ALIAS: &amp;ldquo;ETS&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Erlang Term Storage, commonly referred to as ETS, is a powerful storage engine
built into &lt;a href=&#34;/notes/2024/otp/&#34;&gt;Otp&lt;/a&gt;. Every entry in an ETS table is a tuple (or corresponding
record), and one piece of the tuple is designated the key.&lt;/p&gt;
&lt;p&gt;ETS can hold four kinds of collections (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Laurent 2017, 141&lt;/a&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sets (&lt;code&gt;set&lt;/code&gt;): Can contain only one entry with a given key.&lt;/li&gt;
&lt;li&gt;Ordered Sets (&lt;code&gt;ordered_set&lt;/code&gt;): Same as a set, but also maintains a traversal
order based on the keys. Great for anything you want to keep in alphabetic or
numeric order.&lt;/li&gt;
&lt;li&gt;Bags (&lt;code&gt;bag&lt;/code&gt;): Lets you store more than one entry with a given key. However, if
you have multiple entries that have identical values, they get combined into
a single entry.&lt;/li&gt;
&lt;li&gt;Duplicate Bags (&lt;code&gt;duplicate_bag&lt;/code&gt;): Not only lets you store more than one entry
with a given key, but also lets you store multiple entries with identical
values.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;creating-and-populating-a-table&#34;&gt;Creating and populating a table&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;ets:new/2&lt;/code&gt; function lets you create a table.&lt;/li&gt;
&lt;li&gt;If you do specify &lt;code&gt;named_table&lt;/code&gt;, processes can reach the table as long as they
know the name, without needing access to that return value.&lt;/li&gt;
&lt;li&gt;Using the &lt;code&gt;keypos&lt;/code&gt; tuple lets you specify which record value should be the key.
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;food&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;calories&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;price&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nn&#34;&gt;ets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;food&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ordered_set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keypos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;#food.name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;named_table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;simple-queries&#34;&gt;Simple Queries&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ets:lookup/2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Laurent, Simon St. 2017. &lt;i&gt;Introducing Erlang: Getting Started in Functional Programming&lt;/i&gt;. O’Reilly Media, Inc.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Erlang"/>
    
    <category term="Elixir"/>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
</feed>
