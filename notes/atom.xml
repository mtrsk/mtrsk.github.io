<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benevides&#39; Blog</title>
  <link href="https://schonfinkel.github.io/notes/"/>
  
    <link href="https://schonfinkel.github.io/notes/atom.xml" rel="self" type="application/atom+xml" />
  
  <updated>2024-11-29T23:50:18Z</updated>
  <author>
    
    
  </author>
  <generator>Hugo</generator>
  <id>https://schonfinkel.github.io/notes/</id>
  
  <entry>
    <title>Konig S Lemma</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/konig-s-lemma/"/>
    <id>https://schonfinkel.github.io/notes/2024/konig-s-lemma/</id>
    <published>2024-10-16T00:00:00Z</published>
    <updated>2024-10-16T00:00:00Z</updated>
    <summary>:ID: c3826363-989c-49d9-905f-f1349f5528b7
Definition A tree that is finitely branching but infinite must have an infinite branch.</summary>
    <content type="html">&lt;p&gt;:ID:       c3826363-989c-49d9-905f-f1349f5528b7&lt;/p&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition&lt;/h2&gt;
&lt;p&gt;A tree that is finitely branching but infinite must have an infinite branch.&lt;/p&gt;
</content>
    
    <category term="Graph Theory"/>
    
    
    <category term="Math"/>
    
  </entry>
  
  <entry>
    <title>Natural Deduction</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/natural-deduction/"/>
    <id>https://schonfinkel.github.io/notes/2024/natural-deduction/</id>
    <published>2024-10-16T00:00:00Z</published>
    <updated>2024-10-16T00:00:00Z</updated>
    <summary>:ID: 1db8ac56-b188-4797-80ed-21ac950a77b9
In natural deduction, we have a collection of proof rules. They allow us to infer formulas from other formulas. By applying these rules in succession, we may infer a conclusion from a set of premises.
Suppose we have a set of formulas \(\phi_1, \phi_2, \phi_3, \ldots, \phi_n\), which we will call premises, and another formula, \(\psi\), which we will call a conclusion. By applying proof rules to the premises, we hope to get some more formulas, and by applying more proof rules to those, to eventually obtain the conclusion.</summary>
    <content type="html">&lt;p&gt;:ID:       1db8ac56-b188-4797-80ed-21ac950a77b9&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In natural deduction, we have a collection of proof rules. They allow us to
infer formulas from other formulas. By applying these rules in succession, we
may infer a conclusion from a set of premises.&lt;/p&gt;
&lt;p&gt;Suppose we have a set of formulas \(\phi_1, \phi_2, \phi_3, \ldots, \phi_n\), which we will call
premises, and another formula, \(\psi\), which we will call a conclusion. By applying
proof rules to the premises, we hope to get some more formulas, and by applying
more proof rules to those, to eventually obtain the conclusion. This intention
we denote by:&lt;/p&gt;
&lt;p&gt;\[\phi_1, \phi_2, \phi_3, \ldots, \phi_n \vdash \psi\]&lt;/p&gt;
&lt;p&gt;This expression is called a &lt;strong&gt;sequent&lt;/strong&gt;; it is valid if a proof for it can be
found.&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Huth and Ryan 2004, 5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;rules-for-natural-deduction&#34;&gt;Rules for Natural Deduction&lt;/h2&gt;
&lt;h3 id=&#34;conjunction&#34;&gt;Conjunction&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\AxiomC{$\psi$}
\RightLabel{$\land i$}
\BinaryInfC{$\phi \land \psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi \land \psi$}
\RightLabel{$\land e_1$}
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi \land \psi$}
\RightLabel{$\land e_2$}
\UnaryInfC{$\psi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;double-negation&#34;&gt;Double Negation&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\RightLabel{$\lnot \lnot i$}
\UnaryInfC{$\lnot \lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\lnot \lnot \phi$}
\RightLabel{$\lnot \lnot e$}
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;implication&#34;&gt;Implication&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\AxiomC{$\phi \to \psi$}
\RightLabel{$\to_e$}
\BinaryInfC{$\psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;in order to prove \(\phi \to \psi\), make a temporary assumption of \(\phi\) and then prove \(\psi\).&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\psi$}
\RightLabel{$\to_i$}
\alwaysSingleLine
\UnaryInfC{$\phi \to \psi$}
\end{prooftree}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Showing \(p \to q\) using the rule \(\to_i\) rule is now called &lt;strong&gt;type checking&lt;/strong&gt;, an
important topic in the construction of compilers for typed programming
languages. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Huth and Ryan 2004, 12&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;disjunction&#34;&gt;Disjunction&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\phi$}
\RightLabel{$\lor i_1$}
\UnaryInfC{$\phi \lor \psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\psi$}
\RightLabel{$\lor i_2$}
\UnaryInfC{$\phi \lor \psi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;To dissasemble a disjunction, we need to show that either \(\phi \vdash \chi\) or \(\psi
\vdash \chi\):&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{$\phi \lor \psi$}
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\chi$}
\AxiomC{[$\psi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\chi$}
\RightLabel{$\lor_e$}
\alwaysSingleLine
\TrinaryInfC{$\chi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;negation&#34;&gt;Negation&lt;/h3&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\bot$}
\RightLabel{$\bot_e$}
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\psi$}
\AxiomC{$\lnot \psi$}
\RightLabel{$\lnot_e$}
\BinaryInfC{$\bot$}
\end{prooftree}&lt;/p&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\bot$}
\RightLabel{$\lnot_i$}
\alwaysSingleLine
\UnaryInfC{$\lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;h3 id=&#34;useful-derived-rules&#34;&gt;Useful Derived Rules&lt;/h3&gt;
&lt;h4 id=&#34;modus-tollens&#34;&gt;Modus Tollens&lt;/h4&gt;
&lt;p&gt;\begin{prooftree}
\AxiomC{$\lnot \psi$}
\AxiomC{$\phi \to \psi$}
\RightLabel{MT}
\BinaryInfC{$\lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;h4 id=&#34;law-of-the-excluded-middle&#34;&gt;Law of the Excluded Middle&lt;/h4&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{}
\RightLabel{LEM}
\alwaysSingleLine
\UnaryInfC{$\phi \lor \lnot \phi$}
\end{prooftree}&lt;/p&gt;
&lt;h4 id=&#34;proof-by-contradiction&#34;&gt;Proof by Contradiction&lt;/h4&gt;
&lt;p&gt;\begin{prooftree}
\alwaysNoLine
\AxiomC{[$\lnot \phi$]}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\bot$}
\RightLabel{$PBC$}
\alwaysSingleLine
\UnaryInfC{$\phi$}
\end{prooftree}&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Huth, Michael, and Mark Ryan. 2004. &lt;i&gt;Logic in Computer Science: Modelling and Reasoning About Systems&lt;/i&gt;. Cambridge university press.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Sequent Calculus"/>
    
    
    <category term="Logic"/>
    
  </entry>
  
  <entry>
    <title>Tcp Ip</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/tcp-ip/"/>
    <id>https://schonfinkel.github.io/notes/2024/tcp-ip/</id>
    <published>2024-10-16T00:00:00Z</published>
    <updated>2024-10-16T00:00:00Z</updated>
    <summary>:ID: 3bdcfa3b-8fb6-4c4f-97d9-9abaf4aa4a8b
Unlike the Osi Model, but &amp;ldquo;Application&amp;rdquo;, &amp;ldquo;Presentation&amp;rdquo; and &amp;ldquo;Session&amp;rdquo; are folded in a single layer.
Transmission Control Protocol / Internet Protocol </summary>
    <content type="html">&lt;p&gt;:ID:       3bdcfa3b-8fb6-4c4f-97d9-9abaf4aa4a8b&lt;/p&gt;
&lt;p&gt;Unlike the &lt;a href=&#34;/notes/2024/osi-model/&#34;&gt;Osi Model&lt;/a&gt;, but &amp;ldquo;Application&amp;rdquo;, &amp;ldquo;Presentation&amp;rdquo; and &amp;ldquo;Session&amp;rdquo; are
folded in a single layer.&lt;/p&gt;
&lt;h2 id=&#34;transmission-control-protocol-internet-protocol&#34;&gt;Transmission Control Protocol / Internet Protocol&lt;/h2&gt;
&lt;figure&gt;&lt;img src=&#34;/img/notes/tcp_ip_diagram.png&#34;&gt;
&lt;/figure&gt;

</content>
    
    <category term="TCP/IP"/>
    
    
    <category term="Networking"/>
    
  </entry>
  
  <entry>
    <title>Osi Model</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/osi-model/"/>
    <id>https://schonfinkel.github.io/notes/2024/osi-model/</id>
    <published>2024-10-15T00:00:00Z</published>
    <updated>2024-10-15T00:00:00Z</updated>
    <summary>:ID: e1a39e7c-50a7-4ad8-84f0-dfb7a8864e8b
The Open Systems Interconnection (OSI) model is a reference tool for understanding data communications between any two networked systems. It divides the communications processes into seven layers. Each layer both performs specific functions to support the layers above it and offers services to the layers below it.
Physical Layer Data Link MAC Addressing Flow control Error control: Error detection, followed by correction and/or re-transmition. Line discipline Unit of measure: Frames Network IP Addressing Unit of measure: Packets Transport Responsible for providing and managing end-to-end transmission of messages between two end nodes.</summary>
    <content type="html">&lt;p&gt;:ID:       e1a39e7c-50a7-4ad8-84f0-dfb7a8864e8b&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Open Systems Interconnection (OSI) model is a reference tool for
understanding data communications between any two networked systems. It divides
the communications processes into seven layers. Each layer both performs
specific functions to support the layers above it and offers services to the
layers below it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;physical-layer&#34;&gt;Physical Layer&lt;/h2&gt;
&lt;h2 id=&#34;data-link&#34;&gt;Data Link&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MAC Addressing&lt;/li&gt;
&lt;li&gt;Flow control&lt;/li&gt;
&lt;li&gt;Error control: Error detection, followed by correction and/or re-transmition.&lt;/li&gt;
&lt;li&gt;Line discipline&lt;/li&gt;
&lt;li&gt;Unit of measure: Frames&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;network&#34;&gt;Network&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IP Addressing&lt;/li&gt;
&lt;li&gt;Unit of measure: Packets&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;transport&#34;&gt;Transport&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Responsible for providing and managing end-to-end transmission of messages
between two end nodes.&lt;/li&gt;
&lt;li&gt;Maps transport and network addresses, port-based.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;protocols&#34;&gt;Protocols&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TCP: Reliable transfer and guarantees error-free delivery of data in the
correct order.&lt;/li&gt;
&lt;li&gt;UDP: &amp;ldquo;Unreliable&amp;rdquo; transport, no sequence messages.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;session&#34;&gt;Session&lt;/h2&gt;
&lt;h2 id=&#34;presentation&#34;&gt;Presentation&lt;/h2&gt;
&lt;h2 id=&#34;application&#34;&gt;Application&lt;/h2&gt;
</content>
    
    
    <category term="Networking"/>
    
  </entry>
  
  <entry>
    <title>Partial Order</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/partial-order/"/>
    <id>https://schonfinkel.github.io/notes/2024/partial-order/</id>
    <published>2024-10-13T00:00:00Z</published>
    <updated>2024-10-13T00:00:00Z</updated>
    <summary>:ID: a7be7168-8d15-4fe0-a82c-9fd9348b3b93
A Relation \(R\) is said to be a reflexive partial order if its reflexive, antisymmetric, and transitive. </summary>
    <content type="html">&lt;p&gt;:ID:       a7be7168-8d15-4fe0-a82c-9fd9348b3b93&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;a href=&#34;/notes/2024/relation/&#34;&gt;Relation&lt;/a&gt; \(R\) is said to be a &lt;strong&gt;reflexive partial order&lt;/strong&gt; if its &lt;strong&gt;reflexive&lt;/strong&gt;,
&lt;strong&gt;antisymmetric&lt;/strong&gt;, and &lt;strong&gt;transitive&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <category term="Set Theory"/>
    
    
    <category term="Math"/>
    
  </entry>
  
  <entry>
    <title>Relation</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/relation/"/>
    <id>https://schonfinkel.github.io/notes/2024/relation/</id>
    <published>2024-10-13T00:00:00Z</published>
    <updated>2024-10-13T00:00:00Z</updated>
    <summary>:ID: efd79527-1cfb-48da-868e-6286cff21c34
A relation is any subset of a Cartesian product. For instance, a relation \(R\) over any subset of \(X \times X\) is called a &amp;ldquo;Relation on \(X\)&amp;rdquo;.
A Relation \(R\) is said to be reflexive if \(\forall x \in X: (x,x) \in R\). A Relation \(R\) is said to be symmetric if \(\forall x,y \in X: (x,y) \in R \implies (y,x) \in R\). A Relation \(R\) is antisymmetric if \(\forall x,y \in X: (x,y) \in R \land (y,x) \in R \implies x = y\).</summary>
    <content type="html">&lt;p&gt;:ID:       efd79527-1cfb-48da-868e-6286cff21c34&lt;/p&gt;
&lt;p&gt;A relation is any subset of a Cartesian product. For instance, a relation \(R\)
over any subset of \(X \times X\) is called a &amp;ldquo;Relation on \(X\)&amp;rdquo;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Relation \(R\) is said to be &lt;strong&gt;reflexive&lt;/strong&gt; if \(\forall x \in X: (x,x) \in R\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is said to be &lt;strong&gt;symmetric&lt;/strong&gt; if \(\forall x,y \in X: (x,y) \in R \implies (y,x)
\in R\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is &lt;strong&gt;antisymmetric&lt;/strong&gt; if \(\forall x,y \in X: (x,y) \in R \land (y,x) \in R \implies x
= y\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is &lt;strong&gt;transitive&lt;/strong&gt; if \(\forall x,y,z \in X: (x,y) \in R \land (y,z) \in R \implies
(x,z) \in R\).&lt;/li&gt;
&lt;li&gt;A Relation \(R\) is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is &lt;strong&gt;reflexive&lt;/strong&gt;, &lt;strong&gt;symmetric&lt;/strong&gt; and &lt;strong&gt;transitive&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <category term="Set Theory"/>
    
    
    <category term="Math"/>
    
  </entry>
  
  <entry>
    <title>Supervisor</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/supervisor/"/>
    <id>https://schonfinkel.github.io/notes/2024/supervisor/</id>
    <published>2024-10-13T00:00:00Z</published>
    <updated>2024-10-13T00:00:00Z</updated>
    <summary>:ID: 2daf1307-afb4-49e4-98cb-66ac7eb27cf0
Supervisors are one of the most important features of Otp. They monitor other processes and take action if anything goes wrong, restarting the failed process or possibly escalating the problem to a higher level. Layering supervisors into supervision trees allows you to create highly fault-tolerant systems. (Logan, Merritt, and Carlsson 2010)</summary>
    <content type="html">&lt;p&gt;:ID:       2daf1307-afb4-49e4-98cb-66ac7eb27cf0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Supervisors are one of the most important features of &lt;a href=&#34;/notes/2024/otp/&#34;&gt;Otp&lt;/a&gt;. They monitor other
processes and take action if anything goes wrong, restarting the failed process
or possibly escalating the problem to a higher level. Layering supervisors into
supervision trees allows you to create highly fault-tolerant systems. (Logan, Merritt, and Carlsson 2010)&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Dependent Types</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/dependent-types/"/>
    <id>https://schonfinkel.github.io/notes/2024/dependent-types/</id>
    <published>2024-10-11T00:00:00Z</published>
    <updated>2024-10-11T00:00:00Z</updated>
    <summary>:ID: 7580b45a-1dba-4690-bfbf-652fee25e1d9</summary>
    <content type="html">&lt;p&gt;:ID:       7580b45a-1dba-4690-bfbf-652fee25e1d9&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/functional-programming/"/>
    <id>https://schonfinkel.github.io/notes/2024/functional-programming/</id>
    <published>2024-10-11T00:00:00Z</published>
    <updated>2024-10-11T00:00:00Z</updated>
    <summary>:ID: 171718cd-10fd-484b-8d77-0ffcffc29163
We often refer to the term functional programming, meaning the following programming techniques:
Composing functions for structuring programs and using recursion instead of loops. Purity, so that the result of a function is fully determined once its parameters have been fixed. Absence of side effects (doing literally nothing except evaluating the result). Immutability (the inability to change the value of a variable). (, Bragilevsky 2021)
References Bragilevsky, Vitaly. 2021.</summary>
    <content type="html">&lt;p&gt;:ID:       171718cd-10fd-484b-8d77-0ffcffc29163&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We often refer to the term functional programming, meaning the following programming techniques:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Composing functions for structuring programs and using recursion instead of loops.&lt;/li&gt;
&lt;li&gt;Purity, so that the result of a function is fully determined once its parameters have been fixed.&lt;/li&gt;
&lt;li&gt;Absence of side effects (doing literally nothing except evaluating the result).&lt;/li&gt;
&lt;li&gt;Immutability (the inability to change the value of a variable).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(, &lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Bragilevsky 2021&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Bragilevsky, Vitaly. 2021. &lt;i&gt;Haskell in Depth&lt;/i&gt;. Simon and Schuster.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Erlang Ets</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/erlang-ets/"/>
    <id>https://schonfinkel.github.io/notes/2024/erlang-ets/</id>
    <published>2024-10-10T00:00:00Z</published>
    <updated>2024-10-10T00:00:00Z</updated>
    <summary>:ID: 37c6ea44-0c80-4c57-a36e-98d37e8a3413 :ROAM_ALIAS: &amp;ldquo;ETS&amp;rdquo;
Erlang Term Storage, commonly referred to as ETS, is a powerful storage engine built into Otp.</summary>
    <content type="html">&lt;p&gt;:ID:       37c6ea44-0c80-4c57-a36e-98d37e8a3413
:ROAM_ALIAS: &amp;ldquo;ETS&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Erlang Term Storage, commonly referred to as ETS, is a powerful storage engine
built into &lt;a href=&#34;/notes/2024/otp/&#34;&gt;Otp&lt;/a&gt;.&lt;/p&gt;
</content>
    
    <category term="Erlang"/>
    
    <category term="Elixir"/>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Gen Server</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/gen-server/"/>
    <id>https://schonfinkel.github.io/notes/2024/gen-server/</id>
    <published>2024-10-10T00:00:00Z</published>
    <updated>2024-10-10T00:00:00Z</updated>
    <summary>:ID: 1cd8fd81-a7c4-44ea-8b7a-d803e9b491af
Much of the work you think of as the core of a program - calculating results, storing information, and preparing replies - will fit neatly into the gen_server behavior. It provides a core set of methods that let you set up a process, respond to requests, end the process gracefully, and even pass state to a new process if this one needs to be upgraded in place. (Laurent 2017, 148)</summary>
    <content type="html">&lt;p&gt;:ID:       1cd8fd81-a7c4-44ea-8b7a-d803e9b491af&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Much of the work you think of as the core of a program - calculating results,
storing information, and preparing replies - will fit neatly into the &lt;code&gt;gen_server&lt;/code&gt;
behavior. It provides a core set of methods that let you set up a process,
respond to requests, end the process gracefully, and even pass state to a new
process if this one needs to be upgraded in place. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Laurent 2017, 148&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;gen_server&lt;/code&gt; is a generic server process that implements a standard set of
interface functions and functionality for tracing and error reporting, it also
fits an &lt;a href=&#34;/notes/2024/otp/&#34;&gt;Otp&lt;/a&gt; supervision tree.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;gen_server&lt;/code&gt; behaviour interface contains six functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle_call/3&lt;/code&gt;: Sends a synchronous message to a &lt;code&gt;gen_server&lt;/code&gt; process and waits for a reply.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;: Sends an asynchronous message to a &lt;code&gt;gen_server&lt;/code&gt; process.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle_info/2&lt;/code&gt;: Handles messages sent to a &lt;code&gt;gen_server&lt;/code&gt; container that were not sent using one of the call or cast functions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;code_change/3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Laurent, Simon St. 2017. &lt;i&gt;Introducing Erlang: Getting Started in Functional Programming&lt;/i&gt;. O’Reilly Media, Inc.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Erlang"/>
    
    <category term="Elixir"/>
    
    <category term="OTP"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Relational Algebra</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/relational-algebra/"/>
    <id>https://schonfinkel.github.io/notes/2024/relational-algebra/</id>
    <published>2024-10-10T00:00:00Z</published>
    <updated>2024-10-10T00:00:00Z</updated>
    <summary>:ID: 11914357-b272-40fc-8bf6-a0ff98af0c99</summary>
    <content type="html">&lt;p&gt;:ID:       11914357-b272-40fc-8bf6-a0ff98af0c99&lt;/p&gt;
</content>
    
    <category term="Relational Theory"/>
    
    
    <category term="Databases"/>
    
  </entry>
  
  <entry>
    <title>Dializer</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/dializer/"/>
    <id>https://schonfinkel.github.io/notes/2024/dializer/</id>
    <published>2024-10-09T00:00:00Z</published>
    <updated>2024-10-09T00:00:00Z</updated>
    <summary>:ID: 54473599-719d-460b-92ba-3796dd951872
Dialyzer is a static analysis tool that identifies software discrepancies, such as definite type errors, code that is unreachable because of programming errors, and unnecessary tests in Erlang and Elixir modules or an entire codebases.
Erlang Type Notation We can define a subset of Erlang types as follows:
Type :: any() | none() | pid() | port() | reference() | [] | Atom | binary() | float() | Fun | Integer | [Type] | Tuple | Union | UserDefined Union :: Type1 | Type2 | .</summary>
    <content type="html">&lt;p&gt;:ID:       54473599-719d-460b-92ba-3796dd951872&lt;/p&gt;
&lt;p&gt;Dialyzer is a static analysis tool that identifies software discrepancies, such
as definite type errors, code that is unreachable because of programming errors,
and unnecessary tests in &lt;a href=&#34;/notes/2024/erlang/&#34;&gt;Erlang&lt;/a&gt; and &lt;a href=&#34;/notes/2024/elixir/&#34;&gt;Elixir&lt;/a&gt; modules or an entire codebases.&lt;/p&gt;
&lt;h2 id=&#34;erlang-type-notation&#34;&gt;Erlang Type Notation&lt;/h2&gt;
&lt;p&gt;We can define a subset of Erlang types as follows:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-nil&#34; data-lang=&#34;nil&#34;&gt;Type ::
      any()
    | none()
    | pid()
    | port()
    | reference()
    | []
    | Atom
    | binary()
    | float()
    | Fun
    | Integer
    | [Type]
    | Tuple
    | Union
    | UserDefined
Union :: Type1 | Type2 | ...
Atom :: atom() | Erlang_Atom
Integer :: integer() | Min .. Max
Fun :: fun() | fun((...) -&amp;gt; Type)
Tuple :: tuple() | {T1, T2, ... Tn}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;New types can be defined with the following syntax:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NewTypeName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;TVar1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;TVar2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;TVarN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;specifying-the-input-and-output-types-of-a-function&#34;&gt;Specifying the Input and Output Types of a Function&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;ni&#34;&gt;spec&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;FileName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Modes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Why&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;when&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;FileName&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;Modes&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;Mode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;Handle&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;Why&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;error_term&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;exporting-types&#34;&gt;Exporting Types&lt;/h3&gt;
&lt;p&gt;A module can export some types to declare that other modules are allowed to
refer to them as remote types. This declaration has the following form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;export_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;T1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;A1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Tk&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Ak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;opaque-types&#34;&gt;Opaque Types&lt;/h3&gt;
&lt;p&gt;The main use case for opacity in Erlang is to hide the implementation of a data
type, enabling evolving the API while minimizing the risk of breaking consumers.&lt;/p&gt;
&lt;h2 id=&#34;running-dializer&#34;&gt;Running Dializer&lt;/h2&gt;
&lt;h3 id=&#34;things-that-confuse-dializer&#34;&gt;Things that confuse Dializer&lt;/h3&gt;
&lt;p&gt;The dialyzer can get easily confused. We can help prevent this by following a
few simple rules. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Armstrong 2013, 151&lt;/a&gt;).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Avoid using &lt;code&gt;-compile(export_all)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Provide detailed type specifications for all the arguments to the &lt;strong&gt;exported&lt;/strong&gt;
functions in the module.&lt;/li&gt;
&lt;li&gt;Provide default arguments to all elements in a record definition. If you don&amp;rsquo;t
provide a default, the atom &lt;code&gt;undefined&lt;/code&gt; is taken as the default.&lt;/li&gt;
&lt;li&gt;Using anonymous variables in arguments to a function often results in types
that are far less specific than you had intended; try to constrain variables
as much as possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Armstrong, Joe. 2013. “Programming Erlang: Software for a Concurrent World.”&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Erlang"/>
    
    <category term="Elixir"/>
    
    
    <category term="Functional Programming"/>
    
  </entry>
  
  <entry>
    <title>Fallacies Of Distributed Computing</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/fallacies-of-distributed-computing/"/>
    <id>https://schonfinkel.github.io/notes/2024/fallacies-of-distributed-computing/</id>
    <published>2024-10-09T00:00:00Z</published>
    <updated>2024-10-09T00:00:00Z</updated>
    <summary>:ID: 5a3ae2dc-5a54-4ba1-a638-f6090502d8ae
Between 1991 and 1997, engineers at Sun Microsystems collected a list of mistakes that programmers commonly make when writing software for networked computers. Bill Joy, Dave Lyon, L Peter Deutsch, and James Gosling cataloged eight assumptions that developers commonly hold about Distributed Systems. These assumptions, while obviously incorrect when stated explicitly, nevertheless inform many of the decisions that the Sun engineers found in systems of the day. (Perry 2020, 6)</summary>
    <content type="html">&lt;p&gt;:ID:       5a3ae2dc-5a54-4ba1-a638-f6090502d8ae&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Between 1991 and 1997, engineers at Sun Microsystems collected a list of
mistakes that programmers commonly make when writing software for networked
computers. Bill Joy, Dave Lyon, L Peter Deutsch, and James Gosling cataloged
eight assumptions that developers commonly hold about &lt;a href=&#34;/notes/2021/distributed-systems/&#34;&gt;Distributed Systems&lt;/a&gt;. These
assumptions, while obviously incorrect when stated explicitly, nevertheless
inform many of the decisions that the Sun engineers found in systems of the
day. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Perry 2020, 6&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The network is reliable&lt;/li&gt;
&lt;li&gt;Latency is zero&lt;/li&gt;
&lt;li&gt;Bandwidth is infinite&lt;/li&gt;
&lt;li&gt;The network is secure&lt;/li&gt;
&lt;li&gt;Topology doesn&amp;rsquo;t change&lt;/li&gt;
&lt;li&gt;There is one administrator&lt;/li&gt;
&lt;li&gt;Transport cost is zero&lt;/li&gt;
&lt;li&gt;The network is homogenous&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Perry, Michael L. 2020. &lt;i&gt;The Art of Immutable Architecture&lt;/i&gt;. Springer.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Fallacies"/>
    
    
    <category term="Distributed Systems"/>
    
  </entry>
  
  <entry>
    <title>Immutable Architectures</title>
    <link rel="alternate" href="https://schonfinkel.github.io/notes/2024/immutable-architectures/"/>
    <id>https://schonfinkel.github.io/notes/2024/immutable-architectures/</id>
    <published>2024-10-09T00:00:00Z</published>
    <updated>2024-10-09T00:00:00Z</updated>
    <summary>:ID: 0fee39a3-5d70-4dfb-8603-7d50d8e4777e
Properties of a reliable application:
Idempotence Immutability Local Independence Versioning In 2015, Pat Helland wrote &amp;ldquo;Immutability Changes Everything&amp;rdquo;, an analysis of several computing solutions based on immutability. It demonstrates that immutability solves many problems in several layers of computational abstraction. (&amp;hellip;) . This paper claims no new ideas but only serves to point out the common thread of immutability in all of these solutions. (Perry 2020)
Forms of Immutable Architectures Name Definition Objects Things that change Records Things that do not change References Perry, Michael L.</summary>
    <content type="html">&lt;p&gt;:ID:       0fee39a3-5d70-4dfb-8603-7d50d8e4777e&lt;/p&gt;
&lt;p&gt;Properties of a reliable application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Idempotence&lt;/li&gt;
&lt;li&gt;Immutability&lt;/li&gt;
&lt;li&gt;Local Independence&lt;/li&gt;
&lt;li&gt;Versioning&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In 2015, Pat Helland wrote &amp;ldquo;Immutability Changes Everything&amp;rdquo;, an analysis of
several computing solutions based on immutability. It demonstrates that
immutability solves many problems in several layers of computational
abstraction. (&amp;hellip;) . This paper claims no new ideas but only serves to point out
the common thread of immutability in all of these solutions. (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Perry 2020&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;forms-of-immutable-architectures&#34;&gt;Forms of Immutable Architectures&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Definition&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Objects&lt;/td&gt;
&lt;td&gt;Things that change&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Records&lt;/td&gt;
&lt;td&gt;Things that do not change&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Perry, Michael L. 2020. &lt;i&gt;The Art of Immutable Architecture&lt;/i&gt;. Springer.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    <category term="Immutable Architectures"/>
    
    
    <category term="Distributed Systems"/>
    
  </entry>
  
</feed>
