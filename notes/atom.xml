<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benevide&#39;s Blog</title>
  <link href="https://mtrsk.github.io/notes/"/>
  
    <link href="https://mtrsk.github.io/notes/atom.xml" rel="self" type="application/atom+xml" />
  
  <updated>2024-07-07T02:31:20Z</updated>
  <author>
    
    
  </author>
  <generator>Hugo</generator>
  <id>https://mtrsk.github.io/notes/</id>
  
  <entry>
    <title>Introducing Erlang: Getting Started in Functional Programming</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2024/introducing-erlang/"/>
    <id>https://mtrsk.github.io/notes/2024/introducing-erlang/</id>
    <published>2024-07-06T00:00:00Z</published>
    <updated>2024-07-06T00:00:00Z</updated>
    <summary>:ID: f5e7bb90-792d-406a-8c40-2b072db63a13
Chapter 1: Getting Comfortable Numbers in Erlang If you need to do calculations on integers using a base other than 10, you can use Base#Value notation.
Seeing Your Bound Variables b() shows all bound variables in the current erlang shell.
&amp;gt; b(). N = 1 Number = 5 Clearing Bound Variables in the Shell &amp;gt; f(N). &amp;gt; f(). Chapter 2: Functions and Modules Defining Modules -module(drop). -export([fall_velocity/1, mps_to_mph/1, mps_to_kph/1]).</summary>
    <content type="html">&lt;p&gt;:ID:       f5e7bb90-792d-406a-8c40-2b072db63a13&lt;/p&gt;
&lt;h2 id=&#34;chapter-1-getting-comfortable&#34;&gt;Chapter 1: Getting Comfortable&lt;/h2&gt;
&lt;h3 id=&#34;numbers-in-erlang&#34;&gt;Numbers in Erlang&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If you need to do calculations on integers using a base other than 10, you can use
Base#Value notation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;seeing-your-bound-variables&#34;&gt;Seeing Your Bound Variables&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;b()&lt;/code&gt; shows all bound variables in the current erlang shell.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;gt; b&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;Number&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;clearing-bound-variables-in-the-shell&#34;&gt;Clearing Bound Variables in the Shell&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;gt; f&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;N&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;gt; f&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;chapter-2-functions-and-modules&#34;&gt;Chapter 2: Functions and Modules&lt;/h2&gt;
&lt;h3 id=&#34;defining-modules&#34;&gt;Defining Modules&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-erlang&#34; data-lang=&#34;erlang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;drop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fall_velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mps_to_mph&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mps_to_kph&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;fall_velocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Distance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Distance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mps_to_mph&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Mps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;23693629&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Mps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mps_to_kph&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Mps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Mps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Programming Erlang: Software for a Concurrent World</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2024/programming-erlang-software-for-a-concurrent-world/"/>
    <id>https://mtrsk.github.io/notes/2024/programming-erlang-software-for-a-concurrent-world/</id>
    <published>2024-07-06T00:00:00Z</published>
    <updated>2024-07-06T00:00:00Z</updated>
    <summary>:ID: 1daea4ea-40bc-406d-8d03-906c7f9ec343 :ROAM_REFS: &amp;ldquo;Programming Erlang&amp;rdquo;</summary>
    <content type="html">&lt;p&gt;:ID:       1daea4ea-40bc-406d-8d03-906c7f9ec343
:ROAM_REFS: &amp;ldquo;Programming Erlang&amp;rdquo;&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Erlang</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2024/erlang/"/>
    <id>https://mtrsk.github.io/notes/2024/erlang/</id>
    <published>2024-06-19T00:00:00Z</published>
    <updated>2024-06-19T00:00:00Z</updated>
    <summary>:ID: de7d0e94-618f-4982-b3e5-8806d88cad5d
Resources:
Etudes for Erlang (Laurent 2017): Notes from [BROKEN LINK: f5e7bb90-792d-406a-8c40-2b072db63a13] (Armstrong 2013): Notes from [BROKEN LINK: 1daea4ea-40bc-406d-8d03-906c7f9ec343] References Armstrong, Joe. 2013. “Programming Erlang: Software for a Concurrent World.” Laurent, Simon St. 2017. Introducing Erlang: Getting Started in Functional Programming. O’Reilly Media, Inc. </summary>
    <content type="html">&lt;p&gt;:ID:       de7d0e94-618f-4982-b3e5-8806d88cad5d&lt;/p&gt;
&lt;p&gt;Resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oreillymedia/etudes-for-erlang&#34;&gt;Etudes for Erlang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(&lt;a href=&#34;#citeproc_bib_item_2&#34;&gt;Laurent 2017&lt;/a&gt;): Notes from [BROKEN LINK: f5e7bb90-792d-406a-8c40-2b072db63a13]&lt;/li&gt;
&lt;li&gt;(&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Armstrong 2013&lt;/a&gt;): Notes from [BROKEN LINK: 1daea4ea-40bc-406d-8d03-906c7f9ec343]&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Armstrong, Joe. 2013. “Programming Erlang: Software for a Concurrent World.”&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_2&#34;&gt;&lt;/a&gt;Laurent, Simon St. 2017. &lt;i&gt;Introducing Erlang: Getting Started in Functional Programming&lt;/i&gt;. O’Reilly Media, Inc.&lt;/div&gt;
&lt;/div&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Monad</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2024/monad/"/>
    <id>https://mtrsk.github.io/notes/2024/monad/</id>
    <published>2024-06-19T00:00:00Z</published>
    <updated>2024-06-19T00:00:00Z</updated>
    <summary>:ID: a3e972e0-8db9-4556-9dca-0e4f6a663236
Haskell class Monad m where (&amp;gt;&amp;gt;=) :: m a -&amp;gt; ( a -&amp;gt; m b) -&amp;gt; m b (&amp;gt;&amp;gt;) :: m a -&amp;gt; m b -&amp;gt; m b return :: a -&amp;gt; m a Name Handles Signature Result Errors Either e a -&amp;gt; (a -&amp;gt; Either e b) -&amp;gt; Either e b Maybe Absent values Maybe a -&amp;gt; (a -&amp;gt; Maybe b) -&amp;gt; Maybe b IO Pure/Impure separation IO a -&amp;gt; (a -&amp;gt; IO b) -&amp;gt; IO b State Monadic State State a -&amp;gt; (a -&amp;gt; State b) -&amp;gt; State b Reader Environment Data Reader a -&amp;gt; (a -&amp;gt; Reader b) -&amp;gt; Reader b Writer Writer-Only Data Writer a -&amp;gt; (a -&amp;gt; Writer b) -&amp;gt; Writer b Parser Composing Parsers Parser a -&amp;gt; (a -&amp;gt; Parser b) -&amp;gt; Parser b </summary>
    <content type="html">&lt;p&gt;:ID:       a3e972e0-8db9-4556-9dca-0e4f6a663236&lt;/p&gt;
&lt;h2 id=&#34;haskell&#34;&gt;Haskell&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Monad&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;   &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;         &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;                 &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Handles&lt;/th&gt;
&lt;th&gt;Signature&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Result&lt;/td&gt;
&lt;td&gt;Errors&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Either e a -&amp;gt; (a -&amp;gt; Either e b) -&amp;gt; Either e b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Maybe&lt;/td&gt;
&lt;td&gt;Absent values&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Maybe a -&amp;gt; (a -&amp;gt; Maybe b) -&amp;gt; Maybe b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IO&lt;/td&gt;
&lt;td&gt;Pure/Impure separation&lt;/td&gt;
&lt;td&gt;&lt;code&gt;IO a -&amp;gt; (a -&amp;gt; IO b) -&amp;gt; IO b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;State&lt;/td&gt;
&lt;td&gt;Monadic State&lt;/td&gt;
&lt;td&gt;&lt;code&gt;State a -&amp;gt; (a -&amp;gt; State b) -&amp;gt; State b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reader&lt;/td&gt;
&lt;td&gt;Environment Data&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Reader a -&amp;gt; (a -&amp;gt; Reader b) -&amp;gt; Reader b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Writer&lt;/td&gt;
&lt;td&gt;Writer-Only Data&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Writer a -&amp;gt; (a -&amp;gt; Writer b) -&amp;gt; Writer b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parser&lt;/td&gt;
&lt;td&gt;Composing Parsers&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Parser a -&amp;gt; (a -&amp;gt; Parser b) -&amp;gt; Parser b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Monoid</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2023/monoid/"/>
    <id>https://mtrsk.github.io/notes/2023/monoid/</id>
    <published>2023-10-08T00:00:00Z</published>
    <updated>2023-10-08T00:00:00Z</updated>
    <summary>:ID: d89285be-d7a9-46a1-8a10-e14e73b66935
Definition A monoid is triple \(\left (\mathbb{M}, \cdot, 1 \right)\) such that:
\(\mathbb{M}\) is an non-empty set \(\cdot : \mathbb{M} \times \mathbb{M} \rightarrow \mathbb{M}\) is an associative mapping, i.e., \(\forall t_1, t_2, t_3 \in \mathbb{M}, (t_1 \cdot t_2) \cdot t_3 = t_1 \cdot (t_2 \cdot t_3)\). \(1 \in \mathbb{M}\) is the unit satisfying \(1 \cdot t = t = t \cdot 1, \forall t \in \mathbb{M}\). </summary>
    <content type="html">&lt;p&gt;:ID:       d89285be-d7a9-46a1-8a10-e14e73b66935&lt;/p&gt;
&lt;h2 id=&#34;definition&#34;&gt;Definition&lt;/h2&gt;
&lt;p&gt;A monoid is triple \(\left (\mathbb{M}, \cdot, 1 \right)\) such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\(\mathbb{M}\) is an non-empty set&lt;/li&gt;
&lt;li&gt;\(\cdot : \mathbb{M} \times \mathbb{M} \rightarrow \mathbb{M}\) is an associative mapping, i.e., \(\forall
t_1, t_2, t_3 \in \mathbb{M}, (t_1 \cdot t_2) \cdot t_3 = t_1 \cdot (t_2 \cdot t_3)\).&lt;/li&gt;
&lt;li&gt;\(1 \in \mathbb{M}\) is the &lt;em&gt;unit&lt;/em&gt; satisfying \(1 \cdot t = t = t \cdot 1, \forall t \in \mathbb{M}\).&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Abelian Group</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2023/abelian-group/"/>
    <id>https://mtrsk.github.io/notes/2023/abelian-group/</id>
    <published>2023-10-07T00:00:00Z</published>
    <updated>2023-10-07T00:00:00Z</updated>
    <summary>:ID: 6550857e-ec3f-4b76-80ce-9b86df92601e</summary>
    <content type="html">&lt;p&gt;:ID:       6550857e-ec3f-4b76-80ce-9b86df92601e&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Commutative Ring</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2023/commutative-ring/"/>
    <id>https://mtrsk.github.io/notes/2023/commutative-ring/</id>
    <published>2023-10-07T00:00:00Z</published>
    <updated>2023-10-07T00:00:00Z</updated>
    <summary>:ID: 44839048-b783-4a37-9267-b8e59160d90f</summary>
    <content type="html">&lt;p&gt;:ID:       44839048-b783-4a37-9267-b8e59160d90f&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Left R-Module</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2023/left-r-module/"/>
    <id>https://mtrsk.github.io/notes/2023/left-r-module/</id>
    <published>2023-10-07T00:00:00Z</published>
    <updated>2023-10-07T00:00:00Z</updated>
    <summary>:ID: e4bd8f7b-a64d-4da3-b1e8-289d6fb0c441
Formal Definition Suppose that R is a ring, and 1 is its multiplicative identity. A left R-module M consists of an abelian group (M, +) and an operation · : R × M → M such that ∀ r, s ∈ R and x, y ∈ M, we have:
\begin{align*} r \cdot (x + y) &amp;amp;= r \cdot x + r \cdot y \tag{1}\\ (r + s) \cdot x &amp;amp;= r \cdot x + s \cdot x \tag{2}\\ (r \cdot s) \cdot x &amp;amp;= r \cdot (s \cdot x) \tag{3}\\ 1 \cdot x &amp;amp;= x \tag{4} \end{align*}</summary>
    <content type="html">&lt;p&gt;:ID:       e4bd8f7b-a64d-4da3-b1e8-289d6fb0c441&lt;/p&gt;
&lt;h2 id=&#34;formal-definition&#34;&gt;Formal Definition&lt;/h2&gt;
&lt;p&gt;Suppose that R is a ring, and 1 is its multiplicative identity. A left R-module
M consists of an abelian group (M, +) and an operation · : R × M → M such that
∀ r, s ∈ R and x, y ∈ M, we have:&lt;/p&gt;
&lt;p&gt;\begin{align*}
r \cdot (x + y) &amp;amp;= r \cdot x + r \cdot y \tag{1}\\
(r + s) \cdot x &amp;amp;= r \cdot x + s \cdot x \tag{2}\\
(r \cdot s) \cdot x &amp;amp;= r \cdot (s \cdot x) \tag{3}\\
1 \cdot x &amp;amp;= x \tag{4}
\end{align*}&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>R-Module Homomorphism</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2023/r-module-homomorphism/"/>
    <id>https://mtrsk.github.io/notes/2023/r-module-homomorphism/</id>
    <published>2023-10-07T00:00:00Z</published>
    <updated>2023-10-07T00:00:00Z</updated>
    <summary>:ID: e41608f8-fcf2-4b02-b502-9441c0aee369</summary>
    <content type="html">&lt;p&gt;:ID:       e41608f8-fcf2-4b02-b502-9441c0aee369&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Algebraic Models for Accouting Systems</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2023/algebraic-models-for-accouting-systems/"/>
    <id>https://mtrsk.github.io/notes/2023/algebraic-models-for-accouting-systems/</id>
    <published>2023-10-05T00:00:00Z</published>
    <updated>2023-10-05T00:00:00Z</updated>
    <summary>:ID: 9a03d556-ded4-4096-9a8c-c2147dee70a5 :ROAM_ALIASES: &amp;ldquo;Algebra&amp;rdquo;
Algebraic Models for Accouting Systems
Approaches to Accounting Theory Algebraic concepts employed Balance vectors
A balance vector is a column vector or column matrix the sum of whose entries equals zero. Balance vectors are able to represent the state of an accounting system at any instant. They are also capable of encoding the transactions that are applied to the system. Digraph
The vertices represent accounts and the edges indicate where there are flows of value within the system.</summary>
    <content type="html">&lt;p&gt;:ID:       9a03d556-ded4-4096-9a8c-c2147dee70a5
:ROAM_ALIASES: &amp;ldquo;Algebra&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Algebraic Models for Accouting Systems&lt;/p&gt;
&lt;h2 id=&#34;approaches-to-accounting-theory&#34;&gt;Approaches to Accounting Theory&lt;/h2&gt;
&lt;h3 id=&#34;algebraic-concepts-employed&#34;&gt;Algebraic concepts employed&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Balance vectors&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A balance vector is a column vector or column matrix the sum of whose entries equals zero.&lt;/li&gt;
&lt;li&gt;Balance vectors are able to represent the state of an accounting system at any instant.&lt;/li&gt;
&lt;li&gt;They are also capable of encoding the transactions that are applied to the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Digraph&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The vertices represent accounts and the edges indicate where there are flows
of value within the system. Thus a digraph gives a picture of how value can
flow around an accounting system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Automaton&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The applicability to accounting is clear: the states of the accounting
system are the balance vectors, the inputs are the transactions and the
outputs are the new balance vectors.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[BROKEN LINK: d89285be-d7a9-46a1-8a10-e14e73b66935]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;balance-vectors&#34;&gt;Balance Vectors&lt;/h2&gt;
&lt;h3 id=&#34;the-values-of-an-account&#34;&gt;The values of an account&lt;/h3&gt;
&lt;p&gt;Let there be given a set R together with two binary operations on R called
ddition and multiplication, denoted in the usual way, such that the following
rules hold for all elements \(a, b, c \in R\):&lt;/p&gt;
&lt;p&gt;\begin{align*}
(a + b) + c &amp;amp;= a + (b + c) \tag{1}\\
a + b &amp;amp;= b + a \tag{2}\\
\exists 0 \in R, \forall a \in R, a + 0_r &amp;amp;= a \tag{3}\\
\forall a \in R, \exists (-a) \in R, a + (-a) &amp;amp;= 0 \tag{4}\\
a \times (b \times c) &amp;amp;= (a \times b) \times c \tag{5}\\
a \times b &amp;amp;= b \times a \tag{6}\\
a \times (b + c) &amp;amp;= a \times b + a \times c \tag{7}\\
\exists 1 \in R, \forall a \in R, a \times 1 &amp;amp;= a \tag{8}
\end{align*}&lt;/p&gt;
&lt;p&gt;The first four of these requirements assert that &lt;strong&gt;R&lt;/strong&gt; is an algebraic structure
called an &lt;strong&gt;[BROKEN LINK: 6550857e-ec3f-4b76-80ce-9b86df92601e]&lt;/strong&gt;. With the additional properties (5) through (8) R
becomes a &lt;strong&gt;[BROKEN LINK: 44839048-b783-4a37-9267-b8e59160d90f]&lt;/strong&gt; with identity.&lt;/p&gt;
&lt;p&gt;A commutative ring with identity &lt;strong&gt;R&lt;/strong&gt; is said to be &lt;strong&gt;linearly ordered&lt;/strong&gt; if there is a
non-empty subset &lt;strong&gt;P&lt;/strong&gt; of &lt;strong&gt;R&lt;/strong&gt; not containing 0, called the set of positive elements,
such that the following conditions are satisfied:&lt;/p&gt;
&lt;p&gt;\begin{align*}
a,b \in P \implies a + b \in P &amp;amp;\wedge a \times b \in P \tag{9}\\
\forall a \in R, (a \in P) \lor (a = 0) &amp;amp;\lor (-a \in P) \tag{10}\\
\end{align*}&lt;/p&gt;
&lt;p&gt;The actual concept of a linear order arises when one defines a &amp;lt; b to mean that
b − a ∈ P. The negative elements of R are the elements of the set R \ (P ∪
{0}). On the basis of (9) and (10) it can be shown that the following holds:&lt;/p&gt;
&lt;p&gt;\begin{align*}
\forall a,b \in R, (a &amp;lt; b) \lor (a = b) &amp;amp;\lor (a &amp;gt; b) \tag{11}\\
a,b \in R \wedge a \times b = 0 \implies a = 0 &amp;amp;\lor b = 0 \tag{12}\\
\end{align*}&lt;/p&gt;
&lt;h3 id=&#34;the-state-of-an-accounting-system&#34;&gt;The State of an Accounting System&lt;/h3&gt;
&lt;p&gt;Let &lt;strong&gt;R&lt;/strong&gt; be an &lt;strong&gt;ordered domain&lt;/strong&gt;, which will be the universal set for all account
values, and let n be a positive integer, which will be the number of accounts in
the accounting system. The state of the system at any instant can be described
by listing the values of the accounts, which are assumed to be in some agreed
order, in the form of an n-column vector over &lt;strong&gt;R&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;\begin{equation*}
V = \begin{bmatrix}
v_1 \\
v_2 \\
\vdots \\
v_n \\
\end{bmatrix}
\end{equation*}&lt;/p&gt;
&lt;p&gt;Thus v_i ∈ R is the value of the ith account. The set of all n-column vectors over R is denoted by R^n.&lt;/p&gt;
&lt;p&gt;Of particular importance is the zero vector:&lt;/p&gt;
&lt;p&gt;\begin{equation*}
0 = \begin{bmatrix}
0 \\
0 \\
\vdots \\
0 \\
\end{bmatrix}
\end{equation*}&lt;/p&gt;
&lt;p&gt;Addition can also be defined:&lt;/p&gt;
&lt;p&gt;\begin{equation*}
u + v = \begin{bmatrix}
u_1 + v_1 \\
u_2 + v_2 \\
\vdots \\
u_n + v_n \\
\end{bmatrix}
\end{equation*}&lt;/p&gt;
&lt;p&gt;as well as scalar products:&lt;/p&gt;
&lt;p&gt;\begin{equation*}
r \times v = \begin{bmatrix}
r \times v_1 \\
r \times v_2 \\
\vdots \\
r \times v_n \\
\end{bmatrix}
\end{equation*}&lt;/p&gt;
&lt;p&gt;Let \(u, v, w \in R^n\) and \(r, s \in R\):&lt;/p&gt;
&lt;p&gt;\begin{align*}
(u + v) + w &amp;amp;= u + (v + w) \tag{1}\\
u + v &amp;amp;= v + u \tag{2}\\
v + 0 &amp;amp;= v \tag{3}\\
v + (-v) &amp;amp;= 0 \tag{4}\\
r \times (u + v) &amp;amp;= r \times u + r \times v \tag{5}\\
(r + s) \times u &amp;amp;= r \times u + s \times u \tag{6}\\
(r \times s) \times v &amp;amp;= r \times (s \times v) \tag{7}\\
1_R \times v &amp;amp;= v \tag{8}
\end{align*}&lt;/p&gt;
&lt;p&gt;These properties demonstrate that the set R^n has a recognizable algebraic
structure. Indeed properties (1) – (4) assert that R^n is an [BROKEN LINK: 6550857e-ec3f-4b76-80ce-9b86df92601e], while
the additional properties (5) through (8) make R^n into a [BROKEN LINK: e4bd8f7b-a64d-4da3-b1e8-289d6fb0c441].&lt;/p&gt;
&lt;h4 id=&#34;the-free-r-module-r-n&#34;&gt;The free R-module R^n&lt;/h4&gt;
&lt;p&gt;It turns out that R^n is a particular type of R-module called a Free R-module. To
see what is special about it, consider the so-called elementary column vectors
e(1), e(2), &amp;hellip; , e(n) where the ith entry of e(i) is 1 = 1_R and all other
entries are 0. Thus:&lt;/p&gt;
&lt;p&gt;\begin{equation*}
e(1) = \begin{bmatrix}
1 \\
0 \\
\vdots \\
0 \\
\end{bmatrix}, \,
e(2) = \begin{bmatrix}
0 \\
1 \\
\vdots \\
0 \\
\end{bmatrix},
\,\, (\ldots) \,\,,
e(n) = \begin{bmatrix}
0 \\
0 \\
\vdots \\
n \\
\end{bmatrix}
\end{equation*}&lt;/p&gt;
&lt;p&gt;Now an arbitrary vector \(v \in R^n\) is expressible in terms of these
elementary vectors since:&lt;/p&gt;
&lt;p&gt;\begin{equation*}
v = v_1 \times e(1) + v_2 \times e(2) + \dots + v_n \times e(n)
\end{equation*}&lt;/p&gt;
&lt;style&gt;.org-center { margin-left: auto; margin-right: auto; text-align: center; }&lt;/style&gt;
&lt;div class=&#34;org-center&#34;&gt;
&lt;p&gt;The set of elementary vectors {e(1), . . . , e(n)} is an R-basis of R^n, so that R^n is a free R-module of rank n.&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&#34;balance-vectors-in-r-n&#34;&gt;Balance vectors in R^n&lt;/h4&gt;
&lt;p&gt;The accounts of a company generally fall into three categories:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Asset accounts&lt;/em&gt;, which represent anything owned by the company&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Liability accounts&lt;/em&gt;, which record what is owed by the company to external entities&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Equity accounts&lt;/em&gt; or a &lt;em&gt;profit and loss account&lt;/em&gt;; these show what is owed by the
company to the owners and also show the net assets of the company.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It is a fundamental fact that a double entry accounting system must always be in
balance, a fact which is implied by the accounting equation:&lt;/p&gt;
&lt;p&gt;\begin{equation*}
A - L = E
\end{equation*}&lt;/p&gt;
&lt;p&gt;We proceed now to study the properties of the subset of balance vectors in R^n,
where R is an ordered domain.&lt;/p&gt;
&lt;p&gt;First, let us consider the function σ : R^n → R, which sums the entries of a
column vector \(v \in R^n\).&lt;/p&gt;
&lt;p&gt;\begin{equation*}
\sigma(v) = \sum_{i=0}^{n} v_i
\end{equation*}&lt;/p&gt;
&lt;p&gt;σ has the following properties:&lt;/p&gt;
&lt;p&gt;\begin{align*}
\sigma(v + w) &amp;amp;= \sigma(v) + \sigma(w) \\
\sigma(rv) &amp;amp;= r \sigma(v)\\
\forall v,w \in R^n, r \in R
\end{align*}&lt;/p&gt;
&lt;p&gt;A function between two R-modules with these properties is called an [BROKEN LINK: e41608f8-fcf2-4b02-b502-9441c0aee369].&lt;/p&gt;
&lt;p&gt;Module elements which are sent to zero by a module homomorphism σ form a subset
called the &lt;strong&gt;kernel&lt;/strong&gt;, written \(\text{Ker}(\sigma)\).&lt;/p&gt;
&lt;p&gt;Returning to the particular homomorphism σ, we conclude that its kernel,
i.e. the set of balance vectors, is a submodule of R^n. We shall write
\(\text{Baln} ( R)\) for the set of all balance vectors in R^n, so that
\(\text{Ker}(\sigma) = \text{Baln}( R)\) is a submodule of R^n, which will be called the
balance module of degree n over R.&lt;/p&gt;
&lt;h4 id=&#34;properties-of-the-balance-module&#34;&gt;Properties of the Balance Module&lt;/h4&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Managing a Programming Project</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2023/managing-a-programming-project/"/>
    <id>https://mtrsk.github.io/notes/2023/managing-a-programming-project/</id>
    <published>2023-04-11T00:00:00Z</published>
    <updated>2023-04-11T00:00:00Z</updated>
    <summary>:ID: da4d5031-66cb-4d1c-b8cf-24d12adf5c17
Introduction Your ground rules Adopt a set of unambiguous definitions and stick with them Define your project&amp;rsquo;s development cycle and related all schedules and work process to that cycle Define activities, such as levels of testing, in a consistent way Define a system of documents clearly, consistent and early Your contract Half the horror stories about programming involve either bad contracts or no contract at all
The fact that you are managing a programming project means that you will be running a business.</summary>
    <content type="html">&lt;p&gt;:ID:       da4d5031-66cb-4d1c-b8cf-24d12adf5c17&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;h3 id=&#34;your-ground-rules&#34;&gt;Your ground rules&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Adopt a set of unambiguous definitions and stick with them&lt;/li&gt;
&lt;li&gt;Define your project&amp;rsquo;s &lt;span class=&#34;underline&#34;&gt;development cycle&lt;/span&gt; and related all schedules and work
process to that cycle&lt;/li&gt;
&lt;li&gt;Define activities, such as &lt;span class=&#34;underline&#34;&gt;levels of testing&lt;/span&gt;, in a consistent way&lt;/li&gt;
&lt;li&gt;Define a &lt;span class=&#34;underline&#34;&gt;system of documents&lt;/span&gt; clearly, consistent and early&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;your-contract&#34;&gt;Your contract&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Half the horror stories about programming involve either bad contracts or no
contract at all&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--quoteend--&gt;
&lt;blockquote&gt;
&lt;p&gt;The fact that you are managing a programming project means that you will be
running a business. You will have suppliers, you will have one or more
customers. You will have employees, you will have commitments, you will have
financial goals, you will have measured results. (&amp;hellip;) . Your responsibility is
to manage your business so that everyone - your &amp;ldquo;investors&amp;rdquo; (the executives that
gave you the assignment), your customers (the people who will use your system
for a long time to come), your employees (&amp;hellip;), and you - will look at your
operating results and feel a sense of satisfaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;writing-your-own-contract&#34;&gt;Writing your own contract&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Scope of work&lt;/li&gt;
&lt;li&gt;Schedule and deliverables&lt;/li&gt;
&lt;li&gt;Key customer people&lt;/li&gt;
&lt;li&gt;Reviews&lt;/li&gt;
&lt;li&gt;Change management procedures&lt;/li&gt;
&lt;li&gt;Testing constraints&lt;/li&gt;
&lt;li&gt;Acceptance criteria&lt;/li&gt;
&lt;li&gt;Additional constraints&lt;/li&gt;
&lt;li&gt;Price&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;the-nature-of-the-beast&#34;&gt;The nature of the beast&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;Why is software hard to build?&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The System&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;In order for a system that you are building to be useful, it needs to satisfy
the needs of other systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Interactions&lt;/li&gt;
&lt;li&gt;Change&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>Distributed Systems</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2021/distributed-systems/"/>
    <id>https://mtrsk.github.io/notes/2021/distributed-systems/</id>
    <published>2021-11-20T00:00:00Z</published>
    <updated>2021-11-20T00:00:00Z</updated>
    <summary>:ID: d7efb05f-fb8f-438c-b09d-ea91dc24ebc3
Readings from the following books:
Michael L. Perry&amp;rsquo;s &amp;ldquo;The Art of Immutable Architecture&amp;rdquo;. Properties of a reliable application
Idempotence Immutability Local Independence Versioning Why Immutable Architecture ..if you are in architecture, you are responsible for cutting the Gordian Knot of possible failures and mitigations. This is the fragile process by which we build the systems that run our society.
The Problems with Immutability It&amp;rsquo;s not how machines actually operate, i.</summary>
    <content type="html">&lt;p&gt;:ID:       d7efb05f-fb8f-438c-b09d-ea91dc24ebc3&lt;/p&gt;
&lt;p&gt;Readings from the following books:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Michael L. Perry&amp;rsquo;s &amp;ldquo;The Art of Immutable Architecture&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Properties of a reliable application&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Idempotence&lt;/li&gt;
&lt;li&gt;Immutability&lt;/li&gt;
&lt;li&gt;Local Independence&lt;/li&gt;
&lt;li&gt;Versioning&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;why-immutable-architecture&#34;&gt;Why Immutable Architecture&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;..if you are in architecture, you are responsible for cutting the Gordian Knot
of possible failures and mitigations. This is the fragile process by which we
build the systems that run our society.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;the-problems-with-immutability&#34;&gt;The Problems with Immutability&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s not how machines actually operate, i.e, we need find a way to represent
fixed mutable memory&lt;/li&gt;
&lt;li&gt;Modelling mutable actions that need to be solved by our immutable system&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-fallacies-of-distributed-computing&#34;&gt;The Fallacies of Distributed Computing&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;The network is reliable&lt;/li&gt;
&lt;li&gt;Latency is zero&lt;/li&gt;
&lt;li&gt;Bandwidth is infinite&lt;/li&gt;
&lt;li&gt;The network is secure&lt;/li&gt;
&lt;li&gt;Topology doesn&amp;rsquo;t change&lt;/li&gt;
&lt;li&gt;There is one administrator&lt;/li&gt;
&lt;li&gt;Transport cost is zero&lt;/li&gt;
&lt;li&gt;The network is homogenous&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;changing-assumptions&#34;&gt;Changing Assumptions&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The tools that we use and the patterns that we follow today all evolved from a
time during which assumptions of high reliability, zero latency, and topological
consistency were not fallacies. (&amp;hellip;) When we apply the languages and patterns
of the past to the problems of modern distributed systems, it is no wonder that
programmers will make incorrect assumptions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;structural-sharing&#34;&gt;Structural Sharing&lt;/h3&gt;
&lt;p&gt;A common optimization for immutable data structures that is enabled by immutable
data structures.&lt;/p&gt;
&lt;h3 id=&#34;the-two-generals-problem&#34;&gt;The Two Generals&amp;rsquo; Problem&lt;/h3&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
  <entry>
    <title>History of Logic: From Aristotle to Taski</title>
    <link rel="alternate" href="https://mtrsk.github.io/notes/2021/history-of-logic-from-aristotle-to-taski/"/>
    <id>https://mtrsk.github.io/notes/2021/history-of-logic-from-aristotle-to-taski/</id>
    <published>2021-11-11T00:00:00Z</published>
    <updated>2021-11-11T00:00:00Z</updated>
    <summary>:ID: 0c082d02-4771-4860-8119-83b263c00ff3
Notes from the book &amp;ldquo;History of Logic: from Aristotle to Tarski&amp;rdquo;.
Intro Roughly speaking, the development of logic in Europe has had three &amp;ldquo;golden ages&amp;rdquo;:
Greek period, from around 350 to 200 BCE and included thinkers like: Aristotle Diodoru Cronus Chrysippus High medieval period, from around 1100 to 1400 Modern period, from around 1850 up to the present day The Greek period From the beginning of the Greek golden period we get many anticipations of later developments.</summary>
    <content type="html">&lt;p&gt;:ID:       0c082d02-4771-4860-8119-83b263c00ff3&lt;/p&gt;
&lt;p&gt;Notes from the book &amp;ldquo;History of Logic: from Aristotle to Tarski&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Roughly speaking, the development of logic in Europe has had three &amp;ldquo;golden
ages&amp;rdquo;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Greek period, from around 350 to 200 BCE and included thinkers like:
&lt;ul&gt;
&lt;li&gt;Aristotle&lt;/li&gt;
&lt;li&gt;Diodoru Cronus&lt;/li&gt;
&lt;li&gt;Chrysippus&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;High medieval period, from around 1100 to 1400&lt;/li&gt;
&lt;li&gt;Modern period, from around 1850 up to the present day&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-greek-period&#34;&gt;The Greek period&lt;/h3&gt;
&lt;p&gt;From the beginning of the Greek golden period we get many anticipations of later
developments. From Aristotle we get a wonderfully worked out system of
&amp;ldquo;term-logic&amp;rdquo;, known as the &amp;ldquo;syllogism&amp;rdquo;, which was a precursor to the first-order
logic, or &amp;ldquo;predicate calculus&amp;rdquo;, and which became easily the most influential
contribution in logic for two thousand years. From the Stoics we get the first
formulations of elements of propositional logic, with definitions of connectives
given via truth-values, but we also see many other interesting formulations of
logical problems, such as proposals for the nature of implication that are very
similar to some contemporary theories on subjunctive and indicative
conditionals. Much of the best work form the Stoic period, notably the work of
Chrysippus, has been lost to history, but we know indirectly that he wrote much
on logic generally, and specifi cally about paradoxes, including the Liar and
the Sorites. It was for a very long time thought that the Aristotelian and Stoic
conceptions of logic were at odds with one another, before their reconciliation
in the modern era under the umbrella of first-order logic.&lt;/p&gt;
&lt;p&gt;The fact that Aristotle’s achievement was so great actually had the unexpected
consequence of holding back logical progress.&lt;/p&gt;
&lt;h3 id=&#34;the-medieval-period&#34;&gt;The medieval period&lt;/h3&gt;
&lt;p&gt;While learning in the West declined, the study of logic was kept alive in the
thriving Islamic world under the Abbasid Caliphate, reaching great heights of
sophistication with notable contributions from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Al-Farabi&lt;/li&gt;
&lt;li&gt;Avicenna&lt;/li&gt;
&lt;li&gt;Averroes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the start of the twelfth century onwards, Europe became increasingly
exposed to the Arabic world, and with this exposure came a rediscovery of the
ancient Greek texts on logic, especially those of Aristotle, along with the
benefit of the sophisticated Arabic commentaries. As these texts circulated
around Europe we find the beginning of our second golden age of logic, from
about 1100 to 1400, the high medieval or &amp;ldquo;scholastic&amp;rdquo; period, with notable
contributors including Peter Abelard, William of Sherwood, Peter of Spain,
William of Ockham and Paul of Venice. Curiously, during this period there was a
combination both innovative progress and reverence for ancient authority, most
particularly that of Aristotle. The progress came in the form of greater
understanding of quantification, reference and logical consequence, a more
intricate treatment of semantics, and developments in modal and temporal logic.&lt;/p&gt;
&lt;p&gt;In the early decades of the sixteenth century, across northern Europe, we find
the introductory arts course being adapted to meet the requirements of an influx
of students from the professional classes. Within this arts course, with its
humanist predilection for Greek and Latin eloquence, and legal and ethical
instruction, there was an acknowledged need for some rigorous underpinning of
instruction in ‘clear thinking’. But the meticulous introduction to formal logic
and semantic theory provided by the scholastic programme came to look
increasingly unsuitable for this purpose.
Lisa Jardine 1982 : 805&lt;/p&gt;
&lt;h3 id=&#34;the-birth-of-calculus&#34;&gt;The birth of Calculus&lt;/h3&gt;
&lt;p&gt;While the study of pure logic may have declined in the early scientific period,
there were a great many advances in mathematics, in particular in algebra and
geometry. By the end of the sixteenth century European mathematicians had
recovered many of the works from antiquity that had been lost, and largely
improved upon the Arabic algebraic developments. This period of mathematical
progress arguably culminated with the creation of the infinitesimal calculus of
Leibniz (1646–1716) and Newton (1642–1727). Leibniz himself was an outstanding
mind who worked in many fields and, against the intellectual tide of his day, he
conducted a solitary programme of innovative research in formal logic. Although
the main body of Leibniz’s works on logic remained relatively unknown until the
turn of the twentieth century, in retrospect he is hugely significant for
articulating a completely new vision of the subject – one that stressed the use
of the recently developed mathematical and algebraic methods.&lt;/p&gt;
&lt;p&gt;Leibniz’s motivations for pursuing an algebraic treatment of logic were deeply
rooted in his philosophical views. He conceived of a mathematically
reconstructed logic as a medium that would refl ect the nature of thought more
faithfully than the comparatively clumsy linguistic approach of the medieval
logicians. The idea was that this new logic, being symbolic rather than
linguistic, would actually improve the way that we think, by laying out the real
elements of thought with perfect clarity, and would therefore be a crucial key
in advancing science generally. In his ambition, Leibniz saw the possibility for
a universal language of thought based on logic; a lingua philosophica (or
‘philosophical language’), which is something that would be recognizable to any
student of analytic philosophy today. Despite the details of Leibniz’s logical
innovations remaining largely out of sight in the Royal Library of Hanover until
the turn of the twentieth century, the general character of his vision managed
to exert an infl uence on a number of early pioneers in the modern age of
logic. For instance, Leibniz’s ideal of a perfect language of thought heavily
infl uenced two of the most important logicians of the early modern period;
George Boole (1815–1864) and Gottlob Frege. This influence is reflected in the
titles of their best known works on logic – Boole’s 1854 work &amp;ldquo;The Laws of
Thought&amp;rdquo; and Frege’s 1879 work &amp;ldquo;Begriffsschrift&amp;rdquo; (which means ‘concept-
script’). Although Boole and Frege diff ered signifi cantly in their approaches,
both were trying to realize the mathematical vision of logic that Leibniz had
envisaged.&lt;/p&gt;
&lt;h3 id=&#34;the-modern-era&#34;&gt;The modern era&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;George Boole: Inspired by Aristotle and Leibniz, Boole managed to encode
logical statements in a algebraic manner.&lt;/li&gt;
&lt;li&gt;Charles Sanders Pierce:   Further developing on Boole&amp;rsquo;s approach, adding many
contributions and taking the bold move to abandon Aristotle&amp;rsquo;s Logic. Pierce
also tried to work with what today looks like Temporal and Modal Logics, and
helped develop and introduce the modern version of quantifiers.&lt;/li&gt;
&lt;li&gt;Gottlob Frege: Alongside Pierce, Frege independentely helped introduce the
idea of universal quantifiers. Frege work is also famous for being what we
would today call &lt;em&gt;Predicate Calculus&lt;/em&gt; in the modern sense, since it contains a
formal language with quantifiers, logical connectives and predicates
(including unary and relational ones), together with a set of Axioms and one
law of inference (&lt;em&gt;Modus Pones&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Russel &amp;amp; Whitehead:&lt;/li&gt;
&lt;li&gt;David Hilbert:&lt;/li&gt;
&lt;li&gt;Kurt Gödel:&lt;/li&gt;
&lt;li&gt;Alfred Tarski: Tarski&amp;rsquo;s landmark paper &amp;ldquo;On the concept of Truth in Formalized
Languages&amp;rdquo; contains a definition of the satisfaction relation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Aristotelian quantifier phrases take two predicates as arguments: they have the
form ‘All A are B’, ‘Some A is B’, ‘No A is B’ or ‘Not all A are B’. Fregean or
Peircian quantifi ers are unary and introduce a bound variable : a variable
standing&lt;/p&gt;
&lt;p&gt;One of the fundamental insights of the algebraic approach to logic was that
logical symbols are subject to interpretation, as symbols in algebra are (for
example, the geometric interpretation of complex numbers). Th is leads naturally
to the idea of a model : an interpretation of the vocabulary of a logical system
which satisfies its axioms. We therefore come to the notion of a Boolean
algebra: any model of Boole’s axioms of logic. Such algebras consist of a set of
atoms, the elements of the algebra; distinguished elements 0 and 1; and
conjunction (intersection or multiplication), disjunction (union or addition)
and complementation (negation or subtraction) operations on the set of
elements. The study of Boolean algebras was begun by Marshall Stone, who proved
a number of important results, including the representation theorem that bears
his name: every Boolean algebra is isomorphic to (that is, has the same
structure as) a Boolean algebra of sets.&lt;/p&gt;
&lt;p&gt;We can trace the birth of model theory to Löwenheim’s paper &amp;ldquo;Über Möglichkeiten
im Relativkalkül&amp;rdquo;. Working within Schröder’s version of the calculus of
relations, Löwenheim showed that if a first-order sentence has a model, then it
has a countable model. Th e Norwegian mathematician Thoralf Skolem improved
Löwenheim’s proof in a paper of 1920, and in doing so generalized the result
from single sentences to (possibly infi nite) sets of sentences. The result is
important because it shows that first-order logic is not, in general, able to
fix the cardinalities of its models: there can, for example, be models of the
theory of real numbers which are countable, or models of set theory where sets
that the theory holds to be uncountable are actually (from the external,
model-theoretic perspective) countable. The completeness theorem for first-order
logic, later proved by Gödel in his 1929 PhD thesis, is an easy corollary of
Skolem’s work from the early 1920s, but this was not understood until later.&lt;/p&gt;
</content>
    
    
    <category term="notes"/>
    
  </entry>
  
</feed>
